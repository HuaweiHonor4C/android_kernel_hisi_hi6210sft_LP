/*
 ******************************************************************************
 *                     INTERPEAK SOURCE FILE
 *
 *   Document no: @(#) $Name: VXWORKS_ITER18A_FRZ10 $ $RCSfile: ipnet_ipv6_icmp_mib.c,v $ $Revision: 1.13 $
 *   $Source: /home/interpeak/CVSRoot/ipnet2/src/ipnet_ipv6_icmp_mib.c,v $
 *   $Author: kenneth $
 *   $State: Exp $ $Locker:  $
 *
 *   INTERPEAK_COPYRIGHT_STRING
 *   Design and implementation by Markus Carlstedt <markus@interpeak.se>
 ******************************************************************************
 */

/*
 ****************************************************************************
 * 1                    DESCRIPTION
 ****************************************************************************
 */

/*
 *===========================================================================
 *                      IPV6-ICMP-MIB
 *===========================================================================
 *
 * Autogenerated by 'ipmibc' with 'smidump 0.4.1' on 2003-11-27 at 13:32:43
 *
 * This file includes initialization code and stubs for MIB variables defined
 * in IPV6-ICMP-MIB. Without any changes it should compile and run with the
 * behaviour that GetRequests succeed with the returned value being
 * zero. SetRequests also succeed but without any actual variables
 * being updated.
 *
 * Modifications to this file are necessary in order to enable read and
 * write operations on actual variables presented in the MIB interface.
 * Each segment in the code where a change is proposed is marked with a
 * 'MIB_TODO' comment together with a pseudo code example describing the
 * modification.
 *
 * This file shall normally be compiled together with the product to which
 * SNMP support is to be added and then linked with the IPSNMP libraries.
 * The MIB is initialized by calling the public initialization function defined
 * at the end of this file. Since no header files are generated its function
 * prototype should be copied into the the product that initializes the MIB.
 *
 */

/*
 ****************************************************************************
 * 2                    CONFIGURATION
 ****************************************************************************
 */

#ifndef IPCOM_KERNEL
#define IPCOM_KERNEL
#endif
#include "ipnet_config.h"


/*
 ****************************************************************************
 * 3                    INCLUDE FILES
 ****************************************************************************
 */

#define IPCOM_USE_CLIB_PROTO
#include <ipcom_type.h>
#include <ipcom_cstyle.h>
#include <ipcom_clib.h>
#include <ipcom_syslog.h>
#include <ipcom_err.h>

#ifdef IPSNMP
#include <ipsnmp_config.h>
#include <ipsnmp.h>
#include <ipnet_h.h>

#if defined(IPCOM_USE_MIB2) && defined(IPCOM_USE_INET6)


/*
 ****************************************************************************
 * 4                    DEFINES
 ****************************************************************************
 */

#ifdef IPCOM_SYSLOG_FACILITY
#undef IPCOM_SYSLOG_FACILITY
#endif
#define IPCOM_SYSLOG_FACILITY    IPCOM_LOG_IPSNMP

#ifdef IPCOM_SYSLOG_PRIORITY
#undef IPCOM_SYSLOG_PRIORITY
#endif
#define IPCOM_SYSLOG_PRIORITY    IPCOM_LOG_DEBUG


/*
 ****************************************************************************
 * 5                    TYPES
 ****************************************************************************
 */

/*
 ****************************************************************************
 * 6                    EXTERNAL PROTOTYPES
 ****************************************************************************
 */

/*
 ****************************************************************************
 * 7                    LOCAL PROTOTYPES
 ****************************************************************************
 */

IP_PUBLIC Ip_err ipnet_ipv6_icmp_mib_init(void);


/*
 ****************************************************************************
 * 8                    DATA
 ****************************************************************************
 */

/*
 ****************************************************************************
 * 9                    STATIC FUNCTIONS
 ****************************************************************************
 */

/*
 *===========================================================================
 *                      ipnet_ipv6_icmp_mib_lock
 *===========================================================================
 * Description: Protects MIB variables in SNMPv2-MIB from multiple access
 * Parameters: lock - boolean that controls lock or unlock
 * Returns: Nothing
 *
 */
IP_STATIC void
ipnet_ipv6_icmp_mib_lock(Ip_bool lock)
{
    if(lock == IP_TRUE)
    {
        IPNET_CODE_LOCK_WRITE();
    }
    else
    {
        IPNET_CODE_UNLOCK();
    }
}


/*
 *===========================================================================
 *                      ipnet_ipv6_icmp_mib_table_search_ipv6IfIcmpTable
 *===========================================================================
 * Description: Searches ipv6IfIcmpTable for a matching entry
 * Parameters: id, buf, best, cmd
 * Returns: Row index of the found entry OR -1 if not found OR -2 for error
 *
 */
IP_STATIC Ipnet_netif *
ipnet_ipv6_icmp_mib_table_search_ipv6IfIcmpTable(char *id,
                                                 char *buf,
                                                 char *best,
                                                 Ip_s32 cmd,
                                                 Ip_s32 *error_code)
{
    Ip_s32       ipv6IfIndex;
    Ip_u32       i;
    Ipnet_netif *netif;
    Ipnet_netif *best_netif = IP_NULL;

    IPNET_NETIF_FOR_EACH(netif, i)
    {
        Ip_s32 lex, len = 0;

        buf[0] = '\0';

        ipv6IfIndex = netif->ipcom.ifindex;

        if(ipcom_snprintf(&buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, "%d.", (int)ipv6IfIndex) < 0)
        {
            *error_code = IPSNMP_ERROR_GENERROR;
            return IP_NULL;
        }
        len = ipcom_strlen(buf);
        if(len)
            buf[len-1] = '\0';

        lex = ipsnmp_util_lexcmp_oid(buf, id);
        if(cmd == IPSNMP_MIB_COMMAND_NEXT)
        {
            if(lex > 0)
            {
                if(best_netif == IP_NULL || ipsnmp_util_lexcmp_oid(buf, best) < 0)
                {
                    ipcom_strcpy(best, buf);
                    best_netif = netif;
                }
            }
        }
        else
        {
            if(lex == 0)
            {
                ipcom_strcpy(best, buf);
                best_netif = netif;
                break;
            }
        }
    }

    if (best_netif == IP_NULL)
        *error_code = IPSNMP_ERROR_NOSUCHNAME;
    return best_netif;
}


/*
 *===========================================================================
 *                      ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable
 *===========================================================================
 * Description: MIB handler for ipv6IfIcmpTable
 * Parameters: See file 'ipsnmp.h'
 * Returns: IPSNMP_ERROR_XXX
 *
 */
IP_STATIC Ip_s32
ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable(Ip_s32 cmd,
                                            char *id,
                                            Ipsnmp_varbind *vb,
                                            Ip_s32 magic,
                                            struct Ipsnmp_node_object *nodeobj)
{
    Ip_s32       lid, ret = -1;
    char        *iid;
    char        *buf = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    char        *best = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    Ipnet_netif *netif;

    (void)vb;
    if(buf == IP_NULL || best == IP_NULL)
    {
        ret = IPSNMP_ERROR_GENERROR;
        goto exit;
    }

    lid = ipsnmp_util_last_subid(nodeobj->id);
    ip_assert(lid >= 1 && lid <= 34);
    netif = ipnet_ipv6_icmp_mib_table_search_ipv6IfIcmpTable(id, buf, best, cmd, &ret);
    if (netif == IP_NULL)
        goto exit;

    if(cmd == IPSNMP_MIB_COMMAND_GET || cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        iid = ipsnmp_create_iid_direct(nodeobj->id, best);
        if(iid == IP_NULL)
        {
            ret = IPSNMP_ERROR_GENERROR;
            goto exit;
        }

        switch(lid)
        {
            case 1:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpInMsgs);
                break;
            case 2:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpInErrors);
                break;
            case 3:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpInDestUnreachs);
                break;
            case 4:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpInAdminProhibs);
                break;
            case 5:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpInTimeExcds);
                break;
            case 6:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpInParmProblems);
                break;
            case 7:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpInPktTooBigs);
                break;
            case 8:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpInEchos);
                break;
            case 9:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpInEchoReplies);
                break;
            case 10:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpInRouterSolicits);
                break;
            case 11:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpInRouterAdvertisements);
                break;
            case 12:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpInNeighborSolicits);
                break;
            case 13:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpInNeighborAdvertisements);
                break;
            case 14:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpInRedirects);
                break;
            case 15:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpInGroupMembQueries);
                break;
            case 16:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpInGroupMembResponses);
                break;
            case 17:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpInGroupMembReductions);
                break;
            case 18:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpOutMsgs);
                break;
            case 19:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpOutErrors);
                break;
            case 20:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpOutDestUnreachs);
                break;
            case 21:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpOutAdminProhibs);
                break;
            case 22:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpOutTimeExcds);
                break;
            case 23:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpOutParmProblems);
                break;
            case 24:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpOutPktTooBigs);
                break;
            case 25:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpOutEchos);
                break;
            case 26:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpOutEchoReplies);
                break;
            case 27:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpOutRouterSolicits);
                break;
            case 28:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpOutRouterAdvertisements);
                break;
            case 29:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpOutNeighborSolicits);
                break;
            case 30:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpOutNeighborAdvertisements);
                break;
            case 31:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpOutRedirects);
                break;
            case 32:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpOutGroupMembQueries);
                break;
            case 33:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpOutGroupMembResponses);
                break;
            case 34:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfIcmpOutGroupMembReductions);
                break;
            default:
                IP_PANIC();
                break;
        }

        ipcom_free(iid);
    }

exit:
    if(buf != IP_NULL)
        ipcom_free(buf);
    if(best != IP_NULL)
        ipcom_free(best);
    return ret;
}


/*
 ****************************************************************************
 * 10                    GLOBAL FUNCTIONS
 ****************************************************************************
 */

/*
 ****************************************************************************
 * 11                    PUBLIC FUNCTIONS
 ****************************************************************************
 */

/*
 *===========================================================================
 *                      ipnet_ipv6_icmp_mib_init
 *===========================================================================
 * Description: Initializes IPV6-ICMP-MIB
 * Parameters: None
 * Returns: IPCOM_SUCCESS or IPCOM_ERR_FAILED
 *
 */
IP_PUBLIC Ip_err
ipnet_ipv6_icmp_mib_init(void)
{
    struct Ipsnmp_node_object nodeobj;
    Ip_s32 ret;

    /* Assign lock function */
    nodeobj.lock = ipnet_ipv6_icmp_mib_lock;

    /* Add node "ipv6IcmpMIB" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.56";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IcmpMIB";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IcmpMIBObjects" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.56.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IcmpMIBObjects";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpTable" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.56.1.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpTable";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpEntry" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpEntry";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpInMsgs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpInMsgs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpInErrors" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.2";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpInErrors";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpInDestUnreachs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.3";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpInDestUnreachs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpInAdminProhibs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.4";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpInAdminProhibs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpInTimeExcds" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.5";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpInTimeExcds";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpInParmProblems" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.6";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpInParmProblems";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpInPktTooBigs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.7";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpInPktTooBigs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpInEchos" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.8";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpInEchos";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpInEchoReplies" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.9";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpInEchoReplies";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpInRouterSolicits" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.10";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpInRouterSolicits";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpInRouterAdvertisements" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.11";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpInRouterAdvertisements";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpInNeighborSolicits" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.12";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpInNeighborSolicits";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpInNeighborAdvertisements" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.13";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpInNeighborAdvertisements";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpInRedirects" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.14";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpInRedirects";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpInGroupMembQueries" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.15";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpInGroupMembQueries";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpInGroupMembResponses" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.16";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpInGroupMembResponses";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpInGroupMembReductions" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.17";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpInGroupMembReductions";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpOutMsgs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.18";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpOutMsgs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpOutErrors" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.19";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpOutErrors";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpOutDestUnreachs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.20";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpOutDestUnreachs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpOutAdminProhibs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.21";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpOutAdminProhibs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpOutTimeExcds" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.22";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpOutTimeExcds";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpOutParmProblems" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.23";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpOutParmProblems";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpOutPktTooBigs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.24";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpOutPktTooBigs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpOutEchos" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.25";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpOutEchos";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpOutEchoReplies" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.26";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpOutEchoReplies";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpOutRouterSolicits" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.27";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpOutRouterSolicits";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpOutRouterAdvertisements" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.28";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpOutRouterAdvertisements";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpOutNeighborSolicits" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.29";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpOutNeighborSolicits";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpOutNeighborAdvertisements" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.30";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpOutNeighborAdvertisements";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpOutRedirects" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.31";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpOutRedirects";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpOutGroupMembQueries" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.32";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpOutGroupMembQueries";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpOutGroupMembResponses" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.33";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpOutGroupMembResponses";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIcmpOutGroupMembReductions" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_icmp_mib_handler_ipv6IfIcmpTable;
    nodeobj.id = "1.3.6.1.2.1.56.1.1.1.34";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIcmpOutGroupMembReductions";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    return IPCOM_SUCCESS;
}

#endif /* #if defined(IPCOM_USE_MIB2) && defined(IPCOM_USE_INET6) */
#endif /* #ifdef IPSNMP */

#if !defined(IPSNMP) || !defined(IPCOM_USE_MIB2)
void ipnet_ipv6_icmp_mib_empty_file(void);
void ipnet_ipv6_icmp_mib_empty_file(void) { }
#endif


/*
 ****************************************************************************
 *                     END OF FILE
 ****************************************************************************
 */

