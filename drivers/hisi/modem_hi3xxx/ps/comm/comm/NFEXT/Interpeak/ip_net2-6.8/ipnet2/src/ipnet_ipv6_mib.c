/*
 ******************************************************************************
 *                     INTERPEAK SOURCE FILE
 *
 *   Document no: @(#) $Name: VXWORKS_ITER18A_FRZ10 $ $RCSfile: ipnet_ipv6_mib.c,v $ $Revision: 1.41 $
 *   $Source: /home/interpeak/CVSRoot/ipnet2/src/ipnet_ipv6_mib.c,v $
 *   $Author: jhorteli $
 *   $State: Exp $ $Locker:  $
 *
 *   INTERPEAK_COPYRIGHT_STRING
 *   Design and implementation by Markus Carlstedt <markus@interpeak.se>
 ******************************************************************************
 */

/*
 ****************************************************************************
 * 1                    DESCRIPTION
 ****************************************************************************
 */

/*
 *===========================================================================
 *                      IPV6-MIB
 *===========================================================================
 *
 * Autogenerated by 'ipmibc' with 'smidump 0.4.1' on 2003-11-26 at 15:19:26
 *
 * This file includes initialization code and stubs for MIB variables defined
 * in IPV6-MIB. Without any changes it should compile and run with the
 * behaviour that GetRequests succeed with the returned value being
 * zero. SetRequests also succeed but without any actual variables
 * being updated.
 *
 * Modifications to this file are necessary in order to enable read and
 * write operations on actual variables presented in the MIB interface.
 * Each segment in the code where a change is proposed is marked with a
 * 'MIB_TODO' comment together with a pseudo code example describing the
 * modification.
 *
 * This file shall normally be compiled together with the product to which
 * SNMP support is to be added and then linked with the IPSNMP libraries.
 * The MIB is initialized by calling the public initialization function defined
 * at the end of this file. Since no header files are generated its function
 * prototype should be copied into the the product that initializes the MIB.
 *
 */

/*
 ****************************************************************************
 * 2                    CONFIGURATION
 ****************************************************************************
 */

#ifndef IPCOM_KERNEL
#define IPCOM_KERNEL
#endif
#include "ipnet_config.h"


/*
 ****************************************************************************
 * 3                    INCLUDE FILES
 ****************************************************************************
 */

#define IPCOM_USE_CLIB_PROTO
#include <ipcom_type.h>
#include <ipcom_cstyle.h>
#include <ipcom_clib.h>
#include <ipcom_syslog.h>
#include <ipcom_err.h>

#ifdef IPSNMP
#include <ipnet_ctrl.h>
#include <ipnet_h.h>
#include <ipnet_loopback.h>
#include <ipnet_usr_sock.h>
#include <ipsnmp.h>
#include <ipsnmp_config.h>

#if defined(IPCOM_USE_MIB2) && defined(IPCOM_USE_INET6)


/*
 ****************************************************************************
 * 4                    DEFINES
 ****************************************************************************
 */

#ifdef IPCOM_SYSLOG_FACILITY
#undef IPCOM_SYSLOG_FACILITY
#endif
#define IPCOM_SYSLOG_FACILITY    IPCOM_LOG_IPSNMP

#ifdef IPCOM_SYSLOG_PRIORITY
#undef IPCOM_SYSLOG_PRIORITY
#endif
#define IPCOM_SYSLOG_PRIORITY    IPCOM_LOG_DEBUG


/*
 ****************************************************************************
 * 5                    TYPES
 ****************************************************************************
 */

typedef struct Ipsnmp_route_walk_struct
{
    Ip_s32 cmd;
    char *id;
    char *buf;
    char *best;
    Ipnet_route_entry *bestrt;
    Ip_bool count_only;
}
Ipsnmp_route_walk;


/*
 ****************************************************************************
 * 6                    EXTERNAL PROTOTYPES
 ****************************************************************************
 */

/*
 ****************************************************************************
 * 7                    LOCAL PROTOTYPES
 ****************************************************************************
 */

IP_PUBLIC Ip_err ipnet_ipv6_mib_init(void);


/*
 ****************************************************************************
 * 8                    DATA
 ****************************************************************************
 */

IP_STATIC Ip_u32 count;
IP_STATIC Ipsnmp_route_walk routewalk;
IP_STATIC struct Ipnet_ip6_addr_entry_struct *bestaddr;


/*
 ****************************************************************************
 * 9                    STATIC FUNCTIONS
 ****************************************************************************
 */

/*
 *===========================================================================
 *                      ipnet_ipv6_mib_lock
 *===========================================================================
 * Description: Protects MIB variables in SNMPv2-MIB from multiple access
 * Parameters: lock - boolean that controls lock or unlock
 * Returns: Nothing
 *
 */
IP_STATIC void
ipnet_ipv6_mib_lock(Ip_bool lock)
{
    if (lock == IP_TRUE)
    {
        IPNET_CODE_LOCK_WRITE();
    }
    else
    {
        IPNET_CODE_UNLOCK();
    }
}

/*
 *===========================================================================
 *                      ipnet_ip_mib_cb_ipv6RouteTable
 *===========================================================================
 * Description:
 * Parameters:
 * Returns:
 *
 */
IP_STATIC Ip_bool
ipnet_ip_mib_cb_ipv6RouteTable(Ipnet_route_entry *rt, Ipsnmp_route_walk *rwp)
{
    Ip_s32 j, lex, len = 0;

    /* Early exit if exact match was found previously */
    if (rwp->bestrt != IP_NULL &&
        (rwp->cmd == IPSNMP_MIB_COMMAND_GET
        || rwp->cmd == IPSNMP_MIB_COMMAND_TEST
        || rwp->cmd == IPSNMP_MIB_COMMAND_SET))
        goto exit;

    if (rt->netif == IP_NULL)
        goto exit;

    /* Do not use hidden entries */
    if(IP_BIT_ISSET(rt->hdr.flags, IPNET_RTF_X_HIDDEN))
        goto exit;

    /* Route must be usable */
    if(IP_BIT_ISFALSE(rt->hdr.flags, IPNET_RTF_UP))
        goto exit;

    /* Do not use link layer entries */
    if (IP_BIT_ISSET(rt->hdr.flags, IPNET_RTF_LLINFO))
        goto exit;

    /* Do not use loopback entries */
    if (IP_BIT_ISSET(rt->netif->ipcom.flags, IP_IFF_LOOPBACK))
        goto exit;

    ip_assert(rt->hdr.key != IP_NULL);

    /* Skip multicast addresses */
    if (IP_IN6_IS_ADDR_MULTICAST((struct Ip_in6_addr *)rt->hdr.key))
        goto exit;

    if (rwp->count_only == IP_TRUE)
    {
        count++;
        goto exit;
    }

    rwp->buf[0] = '\0';

    /* ipv6RouteDest */
    for (j = 0; j < 16; j++)
    {
        if (ipcom_snprintf(&rwp->buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, "%d.", ((Ip_u8 *)rt->hdr.key)[j]) < 0)
            goto exit;
        len = ipcom_strlen(rwp->buf);
    }
    len = ipcom_strlen(rwp->buf);

    /* ipv6RoutePfxLength */
    if (ipcom_snprintf(&rwp->buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, "%d.",
                        ipcom_mask_to_prefixlen(rt->hdr.mask, sizeof(struct Ip_in6_addr) << 3)) < 0)
        return -2;
    len = ipcom_strlen(rwp->buf);

    /* ipv6RouteIndex */
    if (ipcom_snprintf(&rwp->buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, "%d.", 1) < 0)
        return -2;
    len = ipcom_strlen(rwp->buf);
    if (len)
        rwp->buf[len-1] = '\0';

    lex = ipsnmp_util_lexcmp_oid(rwp->buf, rwp->id);
    if (rwp->cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        if (lex > 0)
        {
            if (rwp->bestrt == IP_NULL || ipsnmp_util_lexcmp_oid(rwp->buf, rwp->best) < 0)
            {
                ipcom_strcpy(rwp->best, rwp->buf);
                rwp->bestrt = rt;
            }
        }
    }
    else
    {
        if (lex == 0)
        {
            ipcom_strcpy(rwp->best, rwp->buf);
            rwp->bestrt = rt;
        }
    }

exit:
    /* Do not delete the entry */
    return IP_FALSE;
}


/*
 *===========================================================================
 *                      ipnet_ip_mib_cb_ipv6NetToMediaTable
 *===========================================================================
 * Description:
 * Parameters:
 * Returns:
 *
 */
IP_STATIC Ip_bool
ipnet_ip_mib_cb_ipv6NetToMediaTable(Ipnet_route_entry *rt, Ipsnmp_route_walk *rwp)
{
    Ip_s32 j, lex, len = 0;

    /* Early exit if exact match was found previously */
    if (rwp->bestrt != IP_NULL &&
        (rwp->cmd == IPSNMP_MIB_COMMAND_GET
        || rwp->cmd == IPSNMP_MIB_COMMAND_TEST
        || rwp->cmd == IPSNMP_MIB_COMMAND_SET))
        goto exit;

    if (rt->netif == IP_NULL)
        goto exit;
    /* Do not use hidden entries */
    if (IP_BIT_ISSET(rt->hdr.flags, IPNET_RTF_X_HIDDEN))
        goto exit;
    /* Use only link layer entries */
    if (IP_BIT_ISFALSE(rt->hdr.flags, IPNET_RTF_LLINFO))
        goto exit;
    ip_assert(rt->gateway != IP_NULL);
    ip_assert(rt->hdr.key != IP_NULL);

    rwp->buf[0] = '\0';

    /* ipv6IfIndex */
    if (ipcom_snprintf(&rwp->buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, "%ld.", rt->netif->ipcom.ifindex) < 0)
        return -2;
    len = ipcom_strlen(rwp->buf);

    /* ipv6NetToMediaNetAddress */
    for (j = 0; j < 16; j++)
    {
        if (ipcom_snprintf(&rwp->buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, "%d.", ((Ip_u8 *)rt->hdr.key)[j]) < 0)
            return -2;
        len = ipcom_strlen(rwp->buf);
    }
    len = ipcom_strlen(rwp->buf);
    if (len)
        rwp->buf[len-1] = '\0';

    lex = ipsnmp_util_lexcmp_oid(rwp->buf, rwp->id);
    if (rwp->cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        if (lex > 0)
        {
            if (rwp->bestrt == IP_NULL || ipsnmp_util_lexcmp_oid(rwp->buf, rwp->best) < 0)
            {
                ipcom_strcpy(rwp->best, rwp->buf);
                rwp->bestrt = rt;
            }
        }
    }
    else
    {
        if (lex == 0)
        {
            ipcom_strcpy(rwp->best, rwp->buf);
            rwp->bestrt = rt;
        }
    }

exit:
    /* Do not delete the entry */
    return IP_FALSE;
}


/*
 *===========================================================================
 *                      ipnet_ipv6_mib_handler_ipv6Interfaces
 *===========================================================================
 * Description: MIB handler for ipv6Interfaces
 * Parameters: See file 'ipsnmp.h'
 * Returns: IPSNMP_ERROR_XXX
 *
 */
IP_STATIC Ip_s32
ipnet_ipv6_mib_handler_ipv6Interfaces(Ip_s32 cmd,
                                      char *id,
                                      Ipsnmp_varbind *vb,
                                      Ip_s32 magic,
                                      struct Ipsnmp_node_object *nodeobj)
{
    Ip_s32 ret = -1;
    Ip_u32 ipv6Interfaces;
    char *iid;

    (void)id;
    (void)vb;
    if (cmd == IPSNMP_MIB_COMMAND_GET || cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        iid = ipsnmp_create_iid_integer(nodeobj->id, 0);
        if (iid == IP_NULL)
            return IPSNMP_ERROR_GENERROR;

        ipv6Interfaces = IPNET_NETIF_NUM_ATTACHED;
        ret = ipsnmp_util_put_gauge32(magic, iid, ipv6Interfaces);
        ipcom_free(iid);
    }

    return ret;
}


/*
 *===========================================================================
 *                      ipnet_ipv6_mib_handler_ipv6RouteNumber
 *===========================================================================
 * Description: MIB handler for ipv6RouteNumber
 * Parameters: See file 'ipsnmp.h'
 * Returns: IPSNMP_ERROR_XXX
 *
 */
IP_STATIC Ip_s32
ipnet_ipv6_mib_handler_ipv6RouteNumber(Ip_s32 cmd,
                                       char *id,
                                       Ipsnmp_varbind *vb,
                                       Ip_s32 magic,
                                       struct Ipsnmp_node_object *nodeobj)
{
    Ip_s32       ret = -1;
    Ip_u32       ipv6RouteNumber;
    char        *iid;
    Ipcom_route *rtab;

    (void)id;
    (void)vb;
    if (cmd == IPSNMP_MIB_COMMAND_GET || cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        iid = ipsnmp_create_iid_integer(nodeobj->id, 0);
        if (iid == IP_NULL)
            return IPSNMP_ERROR_GENERROR;

        if (ipnet_route_get_rtab(IP_AF_INET6, 0, IPCOM_ROUTE_TABLE_DEFAULT, &rtab) < 0)
            return IPSNMP_ERROR_GENERROR;

        routewalk.cmd = cmd;
        routewalk.id = IP_NULL;
        routewalk.buf = IP_NULL;
        routewalk.best = IP_NULL;
        routewalk.bestrt = IP_NULL;
        routewalk.count_only = IP_TRUE;
        count = 0;
        /* For now handle only the default route table */
        ipcom_route_walk_tree(rtab,
                              (Ip_bool(*)(Ipcom_route_entry *, void *))
                              ipnet_ip_mib_cb_ipv6RouteTable, &routewalk);
        ipv6RouteNumber = count;

        ret = ipsnmp_util_put_gauge32(magic, iid, ipv6RouteNumber);
        ipcom_free(iid);
    }

    return ret;
}


/*
 *===========================================================================
 *                      ipnet_ipv6_mib_handler_scalars
 *===========================================================================
 * Description: MIB handler for ipv6Forwarding and ipv6DefaultHopLimit
 * Parameters: See file 'ipsnmp.h'
 * Returns: IPSNMP_ERROR_XXX
 *
 */
IP_STATIC Ip_s32
ipnet_ipv6_mib_handler_scalars(Ip_s32 cmd,
                             char *id,
                             Ipsnmp_varbind *vb,
                             Ip_s32 magic,
                             struct Ipsnmp_node_object *nodeobj)
{
    Ip_s32 ret = -1;
    Ip_s32 lid;
    char *iid;

    (void)id;
    lid = ipsnmp_util_last_subid(nodeobj->id);
    ip_assert(lid == 1 || lid == 2);
    if (cmd == IPSNMP_MIB_COMMAND_GET || cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        iid = ipsnmp_create_iid_integer(nodeobj->id, 0);
        if (iid == IP_NULL)
            return IPSNMP_ERROR_GENERROR;

        if (lid == 1)    /* ipv6Forwarding */
        {
            if (IP_BIT_ISSET(ipnet_flags, IPNET_FLAG_IPV6_FORWARD_PKT))
                ret = ipsnmp_util_put_integer(magic, iid, 1);   /* forwarding */
            else
                ret = ipsnmp_util_put_integer(magic, iid, 2);   /* not forwarding */
        }
        else    /* ipv6DefaultHopLimit */
        {
            Ip_s32 ttl;

            ttl = ipcom_sysvar_get_as_int0("ipnet.inet6.BaseHopLimit", 64);
            ret = ipsnmp_util_put_integer(magic, iid, ttl);
        }

        ipcom_free(iid);
    }

    if (cmd == IPSNMP_MIB_COMMAND_TEST || cmd == IPSNMP_MIB_COMMAND_SET)
    {
        Ip_s32 tmp;
        char   buf[16];

        ret = ipsnmp_util_get_integer(vb, &tmp);
        if (ret == IPSNMP_ERROR_NOERROR)
        {
            if (lid == 1)    /* ipv6Forwarding */
            {
                if (tmp != 1 && tmp != 2)
                    return IPSNMP_ERROR_WRONGVALUE;
            }
            else    /* ipv6DefaultHopLimit */
            {
                if (tmp < 0 || tmp > 255)
                    return IPSNMP_ERROR_WRONGVALUE;
            }
        }

        if (ret == IPSNMP_ERROR_NOERROR && cmd == IPSNMP_MIB_COMMAND_SET)
        {
            if (lid == 1)    /* ipv6Forwarding */
            {
                if (tmp == 1)
                    IP_BIT_SET(ipnet_flags, IPNET_FLAG_IPV6_FORWARD_PKT);  /* forwarding */
                else
                    IP_BIT_CLR(ipnet_flags, IPNET_FLAG_IPV6_FORWARD_PKT);  /* not forwarding */

            }
            else    /* ipv6DefaultHopLimit */
            {
                ipcom_sprintf(buf, "%d", (int)tmp);
                if (ipcom_sysvar_set("ipnet.inet6.BaseHopLimit", buf,
                                     IPCOM_SYSVAR_FLAG_OVERWRITE) != IPCOM_SUCCESS)
                {
                    ret = IPSNMP_ERROR_GENERROR;
                }
            }
        }
    }

    return ret;
}


/*
 *===========================================================================
 *                      ipnet_ipv6_mib_table_search_ipv6IfTable
 *===========================================================================
 * Description: Searches ipv6IfTable and ipv6IfStatsTable for a matching entry
 * Parameters:  id, buf, best, cmd
 * Returns:     Pointer to the best netif.
 *
 */
IP_STATIC Ipnet_netif *
ipnet_ipv6_mib_table_search_ipv6IfTable(char *id,
                                        char *buf,
                                        char *best,
                                        Ip_s32 cmd,
                                        Ip_s32 *error_code)
{
    Ip_s32       ipv6IfIndex;
    Ip_u32       i;
    Ipnet_netif *netif;
    Ipnet_netif *best_netif = IP_NULL;

    IPNET_NETIF_FOR_EACH(netif, i)
    {
        Ip_s32 lex, len = 0;

        buf[0] = '\0';

        ipv6IfIndex = netif->ipcom.ifindex;

        if (ipcom_snprintf(&buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, "%d.", (int)ipv6IfIndex) < 0)
        {
            *error_code = IPSNMP_ERROR_GENERROR;
            return IP_NULL;
        }
        len = ipcom_strlen(buf);
        if (len)
            buf[len-1] = '\0';

        lex = ipsnmp_util_lexcmp_oid(buf, id);
        if (cmd == IPSNMP_MIB_COMMAND_NEXT)
        {
            if (lex > 0)
            {
                if (best_netif == IP_NULL || ipsnmp_util_lexcmp_oid(buf, best) < 0)
                {
                    ipcom_strcpy(best, buf);
                    best_netif = netif;
                }
            }
        }
        else
        {
            if (lex == 0)
            {
                ipcom_strcpy(best, buf);
                best_netif = netif;
                break;
            }
        }
    }

    if (best_netif == IP_NULL)
        *error_code = IPSNMP_ERROR_NOSUCHNAME;
    return best_netif;
}


/*
 *===========================================================================
 *                      ipnet_ipv6_mib_table_search_ipv6AddrPrefixTable
 *===========================================================================
 * Description: Searches ipv6AddrPrefixTable for a matching entry
 * Parameters: id, buf, best, cmd
 * Returns:    Best matching interface or IP_NULL if no match was found.
 *
 */
IP_STATIC Ipnet_netif *
ipnet_ipv6_mib_table_search_ipv6AddrPrefixTable(char *id,
                                                char *buf,
                                                char *best,
                                                Ip_s32 cmd,
                                                Ip_s32 *error_code)
{
    Ip_s32       ipv6IfIndex;
    Ip_u8       *ipv6AddrPrefix;
    Ip_s32       ipv6AddrPrefix_len;
    Ip_s32       ipv6AddrPrefixLength;
    Ip_u32       i;
    Ipnet_netif *netif;
    Ipnet_netif *best_netif = IP_NULL;

    bestaddr = IP_NULL;
    IPNET_NETIF_FOR_EACH(netif, i)
    {
        struct Ipnet_ip6_addr_entry_struct *addr;

        buf[0] = '\0';

        *error_code = IPSNMP_ERROR_GENERROR;
        addr = netif->inet6_addr_list;
        while(addr != IP_NULL)
        {
            Ip_s32 j, lex, len = 0;

            ipv6IfIndex = netif->ipcom.ifindex;

            if (ipcom_snprintf(&buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, "%d.", (int)ipv6IfIndex) < 0)
                return IP_NULL;
            len = ipcom_strlen(buf);

            ipv6AddrPrefix = addr->addr.in6.addr8;
            ipv6AddrPrefix_len = addr->prefixlen>>3;

            if (ipcom_snprintf(&buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, "%d.", (int)ipv6AddrPrefix_len) < 0)
                return IP_NULL;
            len = ipcom_strlen(buf);
            for (j = 0; j < ipv6AddrPrefix_len; j++)
            {
                if (ipcom_snprintf(&buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, "%d.", ipv6AddrPrefix[j]) < 0)
                    return IP_NULL;
                len = ipcom_strlen(buf);
            }
            len = ipcom_strlen(buf);

            ipv6AddrPrefixLength = addr->prefixlen;

            if (ipcom_snprintf(&buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, "%d.", (int)ipv6AddrPrefixLength) < 0)
                return IP_NULL;
            len = ipcom_strlen(buf);
            if (len)
                buf[len-1] = '\0';

            lex = ipsnmp_util_lexcmp_oid(buf, id);
            if (cmd == IPSNMP_MIB_COMMAND_NEXT)
            {
                if (lex > 0)
                {
                    if (best_netif == IP_NULL || ipsnmp_util_lexcmp_oid(buf, best) < 0)
                    {
                        ipcom_strcpy(best, buf);
                        best_netif = netif;
                        bestaddr = addr;
                    }
                }
            }
            else
            {
                if (lex == 0)
                {
                    ipcom_strcpy(best, buf);
                    best_netif = netif;
                    bestaddr = addr;
                    goto done;
                }
            }
            addr = addr->next;
        }
    }

done:

    if (best_netif == IP_NULL)
        *error_code = IPSNMP_ERROR_NOSUCHNAME;
    return best_netif;
}


/*
 *===========================================================================
 *                      ipnet_ipv6_mib_table_search_ipv6AddrTable
 *===========================================================================
 * Description: Searches ipv6AddrTable for a matching entry
 * Parameters: id, buf, best, cmd
 * Returns:    Best netif or IP_NULL if matching interface was found.
 *
 */
IP_STATIC Ipnet_netif *
ipnet_ipv6_mib_table_search_ipv6AddrTable(char *id,
                                          char *buf,
                                          char *best,
                                          Ip_s32 cmd,
                                          Ip_s32 *error_code)
{
    Ip_s32       ipv6IfIndex;
    Ip_u8       *ipv6AddrAddress;
    Ip_s32       ipv6AddrAddress_len;
    Ip_u32       i;
    Ipnet_netif *netif;
    Ipnet_netif *best_netif = IP_NULL;

    bestaddr = IP_NULL;
    *error_code = IPSNMP_ERROR_GENERROR;
    IPNET_NETIF_FOR_EACH(netif, i)
    {
        struct Ipnet_ip6_addr_entry_struct *addr;

        buf[0] = '\0';

        addr = netif->inet6_addr_list;
        while(addr != IP_NULL)
        {
            Ip_s32 j, lex, len = 0;

            /* Skip multicast addresses */
            if (IP_IN6_IS_ADDR_MULTICAST(&addr->addr))
                goto next;

            ipv6IfIndex = netif->ipcom.ifindex;

            if (ipcom_snprintf(&buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, "%d.", (int)ipv6IfIndex) < 0)
                return IP_NULL;
            len = ipcom_strlen(buf);

            ipv6AddrAddress = addr->addr.in6.addr8;
            ipv6AddrAddress_len = 16;

            for (j = 0; j < ipv6AddrAddress_len; j++)
            {
                if (ipcom_snprintf(&buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, "%d.", ipv6AddrAddress[j]) < 0)
                    return IP_NULL;
                len = ipcom_strlen(buf);
            }
            len = ipcom_strlen(buf);
            if (len)
                buf[len-1] = '\0';

            lex = ipsnmp_util_lexcmp_oid(buf, id);
            if (cmd == IPSNMP_MIB_COMMAND_NEXT)
            {
                if (lex > 0)
                {
                    if (best_netif == IP_NULL || ipsnmp_util_lexcmp_oid(buf, best) < 0)
                    {
                        ipcom_strcpy(best, buf);
                        best_netif = netif;
                        bestaddr = addr;
                    }
                }
            }
            else
            {
                if (lex == 0)
                {
                    ipcom_strcpy(best, buf);
                    best_netif = netif;
                    bestaddr = addr;
                    goto done;
                }
            }
next:
            addr = addr->next;
        }
    }

done:
    if (best_netif == IP_NULL)
        *error_code = IPSNMP_ERROR_NOSUCHNAME;
    return best_netif;
}


/*
 *===========================================================================
 *                      ipnet_ipv6_mib_table_search_ipv6RouteTable
 *===========================================================================
 * Description: Searches ipv6RouteTable for a matching entry
 * Parameters: id, buf, best, cmd
 * Returns: Row index of the found entry OR -1 if not found OR -2 for error
 *
 */
IP_STATIC Ip_s32
ipnet_ipv6_mib_table_search_ipv6RouteTable(char *id,
                                           char *buf,
                                           char *best,
                                           Ip_s32 cmd)
{
    Ipcom_route *rtab;

    if (ipnet_route_get_rtab(IP_AF_INET6, 0, IPCOM_ROUTE_TABLE_DEFAULT, &rtab) < 0)
        return -1;

    routewalk.cmd = cmd;
    routewalk.id = id;
    routewalk.buf = buf;
    routewalk.best = best;
    routewalk.bestrt = IP_NULL;
    routewalk.count_only = IP_FALSE;

    /* For now handle only the default route table */
    ipcom_route_walk_tree(rtab,
                          (Ip_bool(*)(Ipcom_route_entry *, void *))
                          ipnet_ip_mib_cb_ipv6RouteTable, &routewalk);

    if (routewalk.bestrt == IP_NULL)
        return -1;
    return 0;
}


/*
 *===========================================================================
 *                      ipnet_ipv6_mib_table_search_ipv6NetToMediaTable
 *===========================================================================
 * Description: Searches ipv6NetToMediaTable for a matching entry
 * Parameters: id, buf, best, cmd
 * Returns: Row index of the found entry OR -1 if not found OR -2 for error
 *
 */
IP_STATIC Ip_s32
ipnet_ipv6_mib_table_search_ipv6NetToMediaTable(char *id,
                                                char *buf,
                                                char *best,
                                                Ip_s32 cmd)
{
    Ipcom_route *rtab;

    if (ipnet_route_get_rtab(IP_AF_INET6, 0, IPCOM_ROUTE_TABLE_DEFAULT, &rtab) < 0)
        return -1;

    routewalk.cmd = cmd;
    routewalk.id = id;
    routewalk.buf = buf;
    routewalk.best = best;
    routewalk.bestrt = IP_NULL;
    routewalk.count_only = IP_FALSE;

    /* For now handle only the default route table */
    ipcom_route_walk_tree(rtab,
                          (Ip_bool(*)(Ipcom_route_entry *, void *))
                          ipnet_ip_mib_cb_ipv6NetToMediaTable, &routewalk);

    if (routewalk.bestrt == IP_NULL)
        return -1;
    return 0;
}


/*
 *===========================================================================
 *                      ipnet_ipv6_mib_handler_ipv6RouteTable
 *===========================================================================
 * Description: MIB handler for ipv6RouteNextHop
 * Parameters: See file 'ipsnmp.h'
 * Returns: IPSNMP_ERROR_XXX
 *
 */
IP_STATIC Ip_s32
ipnet_ipv6_mib_handler_ipv6RouteTable(Ip_s32 cmd,
                                        char *id,
                                        Ipsnmp_varbind *vb,
                                        Ip_s32 magic,
                                        struct Ipsnmp_node_object *nodeobj)
{
    Ip_s32 lid, bestindex, ret = -1;
    char *iid;
    char *buf = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    char *best = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);

    if (buf == IP_NULL || best == IP_NULL)
    {
        ret = IPSNMP_ERROR_GENERROR;
        goto exit;
    }

    lid = ipsnmp_util_last_subid(nodeobj->id);
    ip_assert(lid >= 4 && lid <= 14);
    bestindex = ipnet_ipv6_mib_table_search_ipv6RouteTable(id, buf, best, cmd);
    if (bestindex == -2)
    {
        ret = IPSNMP_ERROR_GENERROR;
        goto exit;
    }
    else if (bestindex == -1)
    {
        ret = IPSNMP_ERROR_NOSUCHNAME;
        goto exit;
    }

    if (cmd == IPSNMP_MIB_COMMAND_GET || cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        iid = ipsnmp_create_iid_direct(nodeobj->id, best);
        if (iid == IP_NULL)
        {
            ret = IPSNMP_ERROR_GENERROR;
            goto exit;
        }

        ip_assert(routewalk.bestrt != IP_NULL);
        switch(lid)
        {
            case 4: /* ipv6RouteIfIndex */
                ret = ipsnmp_util_put_integer(magic, iid, routewalk.bestrt->netif->ipcom.ifindex);
                break;
            case 5: /* ipv6RouteNextHop */
                if (IP_BIT_ISSET(routewalk.bestrt->hdr.flags, IPNET_RTF_GATEWAY))
                {
                    struct Ip_sockaddr_in6 *sa;

                    ip_assert(routewalk.bestrt->gateway != IP_NULL);
                    sa = (struct Ip_sockaddr_in6 *)routewalk.bestrt->gateway;
                    ret = ipsnmp_util_put_octetstring(magic, iid, (Ip_u8 *)&sa->sin6_addr, 16);
                }
                else
                    ret = ipsnmp_util_put_octetstring(magic, iid, (Ip_u8 *)"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 16);
                break;
            case 6: /* ipv6RouteType */
                if (IP_BIT_ISSET(routewalk.bestrt->hdr.flags, IPNET_RTF_GATEWAY))
                    ret = ipsnmp_util_put_integer(magic, iid, 4);   /* remote */
                else
                    ret = ipsnmp_util_put_integer(magic, iid, 3);   /* local */
                break;
            case 7: /* ipv6RouteProtocol */
                ret = ipsnmp_util_put_integer(magic, iid, 2);   /* local */
                break;
            case 8: /* ipv6RoutePolicy */
                ret = ipsnmp_util_put_integer(magic, iid, 0);
                break;
            case 9: /* ipv6RouteAge */
                ret = ipsnmp_util_put_unsigned32(magic, iid, 0);
                break;
            case 10: /* ipv6RouteNextHopRDI */
                ret = ipsnmp_util_put_unsigned32(magic, iid, 0);
                break;
            case 11: /* ipv6RouteMetric */
                if (IP_BIT_ISSET(routewalk.bestrt->hdr.flags, IPNET_RTF_GATEWAY))
                    ret = ipsnmp_util_put_unsigned32(magic, iid, 1);
                else
                    ret = ipsnmp_util_put_unsigned32(magic, iid, 0);
                break;
            case 12: /* ipv6RouteWeight */
                ret = ipsnmp_util_put_unsigned32(magic, iid, 0);
                break;
            case 13: /* ipv6RouteInfo */
                ret = ipsnmp_util_put_oid(magic, iid, "0.0");
                break;
            case 14: /* ipv6RouteValid */
                ret = ipsnmp_util_put_integer(magic, iid, 1);   /* true */
                break;
            default:
                IP_PANIC();
                ret = IPSNMP_ERROR_GENERROR;
                break;
        }

        ipcom_free(iid);
    }

    if (cmd == IPSNMP_MIB_COMMAND_TEST || cmd == IPSNMP_MIB_COMMAND_SET)
    {
        (void)vb;
        switch(lid)
        {
            case 14: /* ipv6RouteValid */
                ret = IPSNMP_ERROR_NOSUCHNAME;
                break;
            default:
                IP_PANIC();
                ret = IPSNMP_ERROR_GENERROR;
                break;
        }
    }

exit:
    if (buf != IP_NULL)
        ipcom_free(buf);
    if (best != IP_NULL)
        ipcom_free(best);
    return ret;
}


/*
 *===========================================================================
 *                      ipnet_ipv6_mib_handler_ipv6IfTable
 *===========================================================================
 * Description: MIB handler for ipv6IfTable
 * Parameters: See file 'ipsnmp.h'
 * Returns: IPSNMP_ERROR_XXX
 *
 */
IP_STATIC Ip_s32
ipnet_ipv6_mib_handler_ipv6IfTable(Ip_s32 cmd,
                                         char *id,
                                         Ipsnmp_varbind *vb,
                                         Ip_s32 magic,
                                         struct Ipsnmp_node_object *nodeobj)
{
    Ip_s32 lid, ret = -1;
    Ip_s32 ipv6IfAdminStatus = 0;
    char *iid;
    char *buf = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    char *best = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    Ip_u16 identifier[4];
    struct Ip_ifreq ifreq;
    Ipnet_netif *netif;
    Ip_fd fd;

    if (buf == IP_NULL || best == IP_NULL)
    {
        ret = IPSNMP_ERROR_GENERROR;
        goto exit;
    }

    lid = ipsnmp_util_last_subid(nodeobj->id);
    ip_assert(lid >= 2 || lid <= 11);
    netif = ipnet_ipv6_mib_table_search_ipv6IfTable(id, buf, best, cmd, &ret);
    if (netif == IP_NULL)
        goto exit;

    if (cmd == IPSNMP_MIB_COMMAND_GET || cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        iid = ipsnmp_create_iid_direct(nodeobj->id, best);
        if (iid == IP_NULL)
        {
            ret = IPSNMP_ERROR_GENERROR;
            goto exit;
        }

        switch(lid)
        {
            case 2: /* ipv6IfDescr */
                ret = ipsnmp_util_put_octetstring(magic, iid, (Ip_u8 *)netif->ipcom.name, ipcom_strlen(netif->ipcom.name));
                break;
            case 3: /* ipv6IfLowerLayer */
                ret = ipsnmp_util_put_oid(magic, iid, "0.0");
                break;
            case 4: /* ipv6IfEffectiveMtu */
                ret = ipsnmp_util_put_unsigned32(magic, iid, netif->ipcom.mtu);
                break;
            case 5: /* ipv6IfReasmMaxSize */
#ifdef IPNET_USE_PACKET_POOL
                ret = ipsnmp_util_put_unsigned32(magic, iid, ipnet->pkt_pool_max_mtu);
#else
                ret = ipsnmp_util_put_unsigned32(magic, iid, -1);
#endif
                break;
            case 6: /* ipv6IfIdentifier */
                if (netif->ipcom.link_addr != IP_NULL && netif->ipcom.link_addr_size == 6)
                {
                    identifier[0] = ((Ip_u16 *)netif->ipcom.link_addr)[0] ^ ip_htons(0x0200);
                    identifier[1] = ip_htons(0x00ff) | ((Ip_u16 *)netif->ipcom.link_addr)[1];
                    identifier[2] = ip_htons(0xfe00) | (((Ip_u16 *)netif->ipcom.link_addr)[1] & ip_htons(0x00ff));
                    identifier[3] = ((Ip_u16 *)netif->ipcom.link_addr)[2];
                    ret = ipsnmp_util_put_octetstring(magic, iid, (Ip_u8 *)identifier, 8);
                }
                else
                {
                    ret = ipsnmp_util_put_octetstring(magic, iid, IP_NULL, 0);
                }
                break;
            case 7: /* ipv6IfIdentifierLength */
                if (netif->ipcom.link_addr != IP_NULL && netif->ipcom.link_addr_size == 6)
                {
                    ret = ipsnmp_util_put_integer(magic, iid, 64);
                }
                else
                {
                    ret = ipsnmp_util_put_integer(magic, iid, 0);
                }
                break;
            case 8: /* ipv6IfPhysicalAddress */
                ret = ipsnmp_util_put_octetstring(magic, iid, netif->ipcom.link_addr,
                            netif->ipcom.link_addr_size);
                break;
            case 9: /* ipv6IfAdminStatus */
                if (IP_BIT_ISSET(netif->ipcom.flags, IP_IFF_UP))
                    ret = ipsnmp_util_put_integer(magic, iid, 1);
                else
                    ret = ipsnmp_util_put_integer(magic, iid, 2);
                break;
            case 10: /* ipv6IfOperStatus */
                if (IP_BIT_ISSET(netif->ipcom.flags, IP_IFF_UP))
                    ret = ipsnmp_util_put_integer(magic, iid, 1);
                else
                    ret = ipsnmp_util_put_integer(magic, iid, 2);
                break;
            case 11: /* ipv6IfLastChange */
                ret = ipsnmp_util_put_timeticks(magic, iid, netif->ipcom.mib2.ipv6IfLastChange);
                break;
            default:
                IP_PANIC();
                ret = IPSNMP_ERROR_GENERROR;
                break;
        }

        ipcom_free(iid);
    }

    if (cmd == IPSNMP_MIB_COMMAND_TEST || cmd == IPSNMP_MIB_COMMAND_SET)
    {
        switch(lid)
        {
            case 2: /* ipv6IfDescr */
            case 6: /* ipv6IfIdentifier */
            case 7: /* ipv6IfIdentifierLength */
                ret = IPSNMP_ERROR_NOSUCHNAME;
                break;
            case 9: /* ipv6IfAdminStatus */
                ret = ipsnmp_util_get_integer(vb, &ipv6IfAdminStatus);
                if (ret == IPSNMP_ERROR_NOERROR)
                {
                    if (ipv6IfAdminStatus != 1 && ipv6IfAdminStatus != 2)
                    {
                        ret = IPSNMP_ERROR_WRONGVALUE;
                    }
                }

                if (ret == IPSNMP_ERROR_NOERROR && cmd == IPSNMP_MIB_COMMAND_SET)
                {
                    fd = ipnet_do_socket(IP_AF_INET6, IP_SOCK_DGRAM, IP_IPPROTO_UDP, IP_FALSE);
                    if(fd != IP_INVALID_SOCKET)
                    {
                        /* Change interface status */
                        ipcom_memset(&ifreq, 0, sizeof(struct Ip_ifreq));
                        ipcom_strcpy(ifreq.ifr_name, netif->ipcom.name);
                        if (ipnet_sys_socketioctl(fd, IP_SIOCGIFFLAGS, &ifreq) <0)
                        {
                            IPCOM_LOG1(ERR, "Failed to get interface flags: %s", ipcom_strerror(ipcom_errno));
                            ret = IPSNMP_ERROR_GENERROR;
                        }
                        if (ipv6IfAdminStatus == 1)
                            IP_BIT_SET(ifreq.ip_ifr_flags, IP_IFF_UP);
                        else
                            IP_BIT_CLR(ifreq.ip_ifr_flags, IP_IFF_UP);
                        if (ipnet_sys_socketioctl(fd, IP_SIOCSIFFLAGS, &ifreq) < 0)
                        {
                            IPCOM_LOG1(ERR, "Failed to set interface flags: %s", ipcom_strerror(ipcom_errno));
                            ret = IPSNMP_ERROR_GENERROR;
                        }
                        ipnet_sys_socketclose(fd);
                    }
                    else
                    {
                        IPCOM_LOG0(ERR, "Failed to create socket for ioctl call");
                        ret = IPSNMP_ERROR_GENERROR;
                    }
                }
                break;
            default:
                IP_PANIC();
                ret = IPSNMP_ERROR_GENERROR;
                break;
        }
    }

exit:
    if (buf != IP_NULL)
        ipcom_free(buf);
    if (best != IP_NULL)
        ipcom_free(best);
    return ret;
}


/*
 *===========================================================================
 *                      ipnet_ipv6_mib_handler_ipv6IfStatsTable
 *===========================================================================
 * Description: MIB handler for ipv6IfStatsTable
 * Parameters: See file 'ipsnmp.h'
 * Returns: IPSNMP_ERROR_XXX
 *
 */
IP_STATIC Ip_s32
ipnet_ipv6_mib_handler_ipv6IfStatsTable(Ip_s32 cmd,
                                        char *id,
                                        Ipsnmp_varbind *vb,
                                        Ip_s32 magic,
                                        struct Ipsnmp_node_object *nodeobj)
{
    Ip_s32 lid, ret = -1;
    char *iid;
    char *buf = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    char *best = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    Ipnet_netif *netif;

    (void)vb;
    if (buf == IP_NULL || best == IP_NULL)
    {
        ret = IPSNMP_ERROR_GENERROR;
        goto exit;
    }

    lid = ipsnmp_util_last_subid(nodeobj->id);
    ip_assert(lid >= 1 || lid <= 20);
    netif = ipnet_ipv6_mib_table_search_ipv6IfTable(id, buf, best, cmd, &ret);
    if (netif == IP_NULL)
        goto exit;

    if (cmd == IPSNMP_MIB_COMMAND_GET || cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        iid = ipsnmp_create_iid_direct(nodeobj->id, best);
        if (iid == IP_NULL)
        {
            ret = IPSNMP_ERROR_GENERROR;
            goto exit;
        }

        /* ipv6IfStatsTable */
        switch(lid)
        {
            case 1:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsInReceives);
                break;
            case 2:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsInHdrErrors);
                break;
            case 3:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsInTooBigErrors);
                break;
            case 4:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsInNoRoutes);
                break;
            case 5:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsInAddrErrors);
                break;
            case 6:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsInUnknownProtos);
                break;
            case 7:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsInTruncatedPkts);
                break;
            case 8:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsInDiscards);
                break;
            case 9:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsInDelivers);
                break;
            case 10:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsOutForwDatagrams);
                break;
            case 11:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsOutRequests);
                break;
            case 12:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsOutDiscards);
                break;
            case 13:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsOutFragOKs);
                break;
            case 14:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsOutFragFails);
                break;
            case 15:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsOutFragCreates);
                break;
            case 16:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsReasmReqds);
                break;
            case 17:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsReasmOKs);
                break;
            case 18:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsReasmFails);
                break;
            case 19:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsInMcastPkts);
                break;
            case 20:
                ret = ipsnmp_util_put_counter32(magic, iid, netif->ipcom.mib2.ipv6IfStatsOutMcastPkts);
                break;
            default:
                IP_PANIC();
                break;
        }

        ipcom_free(iid);
    }

exit:
    if (buf != IP_NULL)
        ipcom_free(buf);
    if (best != IP_NULL)
        ipcom_free(best);
    return ret;
}


/*
 *===========================================================================
 *                      ipnet_ipv6_mib_handler_ipv6AddrPrefixTable
 *===========================================================================
 * Description: MIB handler for ipv6AddrPrefixTable
 * Parameters: See file 'ipsnmp.h'
 * Returns: IPSNMP_ERROR_XXX
 *
 */
IP_STATIC Ip_s32
ipnet_ipv6_mib_handler_ipv6AddrPrefixTable(Ip_s32 cmd,
                                         char *id,
                                         Ipsnmp_varbind *vb,
                                         Ip_s32 magic,
                                         struct Ipsnmp_node_object *nodeobj)
{
    Ip_s32 lid, ret = -1;
    char *iid;
    char *buf = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    char *best = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    Ipnet_netif *netif;

    (void)vb;
    if (buf == IP_NULL || best == IP_NULL)
    {
        ret = IPSNMP_ERROR_GENERROR;
        goto exit;
    }

    lid = ipsnmp_util_last_subid(nodeobj->id);
    ip_assert(lid >= 3 || lid <= 6);
    netif = ipnet_ipv6_mib_table_search_ipv6AddrPrefixTable(id, buf, best, cmd, &ret);
    if (netif == IP_NULL)
        goto exit;

    if (cmd == IPSNMP_MIB_COMMAND_GET || cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        iid = ipsnmp_create_iid_direct(nodeobj->id, best);
        if (iid == IP_NULL)
        {
            ret = IPSNMP_ERROR_GENERROR;
            goto exit;
        }

        ip_assert(bestaddr != IP_NULL);
        switch(lid)
        {
            case 3: /* ipv6AddrPrefixOnLinkFlag */
                ret = ipsnmp_util_put_integer(magic, iid, 1);   /* true */
                break;
            case 4: /* ipv6AddrPrefixAutonomousFlag */
                ret = ipsnmp_util_put_integer(magic, iid, 1);   /* true */
                break;
            case 5: /* ipv6AddrPrefixAdvPreferredLifetime */
                ret = ipsnmp_util_put_unsigned32(magic, iid, 0);
                break;
            case 6: /* ipv6AddrPrefixAdvValidLifetime */
                ret = ipsnmp_util_put_unsigned32(magic, iid, 0);
                break;
            default:
                IP_PANIC();
                break;
        }

        ipcom_free(iid);
    }

exit:
    if (buf != IP_NULL)
        ipcom_free(buf);
    if (best != IP_NULL)
        ipcom_free(best);
    return ret;
}


/*
 *===========================================================================
 *                      ipnet_ipv6_mib_handler_ipv6AddrTable
 *===========================================================================
 * Description: MIB handler for ipv6AddrTable
 * Parameters: See file 'ipsnmp.h'
 * Returns: IPSNMP_ERROR_XXX
 *
 */
IP_STATIC Ip_s32
ipnet_ipv6_mib_handler_ipv6AddrTable(Ip_s32 cmd,
                                     char *id,
                                     Ipsnmp_varbind *vb,
                                     Ip_s32 magic,
                                     struct Ipsnmp_node_object *nodeobj)
{
    Ip_s32 lid, ret = -1;
    char *iid;
    char *buf = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    char *best = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    Ipnet_netif *netif;

    (void)vb;
    if (buf == IP_NULL || best == IP_NULL)
    {
        ret = IPSNMP_ERROR_GENERROR;
        goto exit;
    }

    lid = ipsnmp_util_last_subid(nodeobj->id);
    ip_assert(lid >= 2 || lid <= 5);
    netif = ipnet_ipv6_mib_table_search_ipv6AddrTable(id, buf, best, cmd, &ret);
    if (netif == IP_NULL)
        goto exit;

    if (cmd == IPSNMP_MIB_COMMAND_GET || cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        iid = ipsnmp_create_iid_direct(nodeobj->id, best);
        if (iid == IP_NULL)
        {
            ret = IPSNMP_ERROR_GENERROR;
            goto exit;
        }

        ip_assert(bestaddr != IP_NULL);
        switch(lid)
        {
            case 2: /* ipv6AddrPfxLength */
                ret = ipsnmp_util_put_integer(magic, iid, bestaddr->prefixlen);
                break;
            case 3: /* ipv6AddrType */
                if (IP_BIT_ISSET(bestaddr->flags, IPNET_IP6_ADDR_FLAG_AUTOMATIC))
                    ret = ipsnmp_util_put_integer(magic, iid, 1);   /* stateless */
                else
                    ret = ipsnmp_util_put_integer(magic, iid, 2);   /* stateful */
                break;
            case 4: /* ipv6AddrAnycastFlag */
                ret = ipsnmp_util_put_integer(magic, iid, 2);   /* false */
                break;
            case 5: /* ipv6AddrStatus */
                IPNET_DATA_LOCK(ipnet->tmo_lock);
                if (ipnet->sec_now >= bestaddr->expires_sec)
                    ret = ipsnmp_util_put_integer(magic, iid, 3);   /* invalid */
                else if (ipnet->sec_now >= bestaddr->preferred_sec)
                    ret = ipsnmp_util_put_integer(magic, iid, 2);   /* deprecated */
                else
                    ret = ipsnmp_util_put_integer(magic, iid, 1);   /* preferred */
                IPNET_DATA_UNLOCK(ipnet->tmo_lock);
                break;
            default:
                IP_PANIC();
                break;
        }

        ipcom_free(iid);
    }

exit:
    if (buf != IP_NULL)
        ipcom_free(buf);
    if (best != IP_NULL)
        ipcom_free(best);
    return ret;
}


/*
 *===========================================================================
 *                      ipnet_ipv6_mib_handler_ipv6NetToMediaTable
 *===========================================================================
 * Description: MIB handler for ipv6NetToMediaTable
 * Parameters: See file 'ipsnmp.h'
 * Returns: IPSNMP_ERROR_XXX
 *
 */
IP_STATIC Ip_s32
ipnet_ipv6_mib_handler_ipv6NetToMediaTable(Ip_s32 cmd,
                                          char *id,
                                          Ipsnmp_varbind *vb,
                                          Ip_s32 magic,
                                          struct Ipsnmp_node_object *nodeobj)
{
    Ip_s32 lid, bestindex, ret = -1;
    Ip_s32 ipv6NetToMediaValid = 0;
    char *iid;
    char *buf = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    char *best = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    struct Ip_sockaddr_dl *dl;
    Ipnet_ip6_nc_entry *nc;
    struct Ipnet_tag_nc_entry tag;
    Ip_s32 state;

    if (buf == IP_NULL || best == IP_NULL)
    {
        ret = IPSNMP_ERROR_GENERROR;
        goto exit;
    }

    lid = ipsnmp_util_last_subid(nodeobj->id);
    ip_assert(lid >= 2 || lid <= 6);
    bestindex = ipnet_ipv6_mib_table_search_ipv6NetToMediaTable(id, buf, best, cmd);
    if (bestindex == -2)
    {
        ret = IPSNMP_ERROR_GENERROR;
        goto exit;
    }
    else if (bestindex == -1)
    {
        ret = IPSNMP_ERROR_NOSUCHNAME;
        goto exit;
    }

    if (cmd == IPSNMP_MIB_COMMAND_GET || cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        iid = ipsnmp_create_iid_direct(nodeobj->id, best);
        if (iid == IP_NULL)
        {
            ret = IPSNMP_ERROR_GENERROR;
            goto exit;
        }

        ip_assert(routewalk.bestrt != IP_NULL);
        switch(lid)
        {
            case 2: /* ipv6NetToMediaPhysAddress */
                dl = (struct Ip_sockaddr_dl *)routewalk.bestrt->gateway;
                ret = ipsnmp_util_put_octetstring(magic, iid,
                        (Ip_u8 *)IP_SOCKADDR_DL_LLADDR(routewalk.bestrt->gateway), dl->sdl_alen);
                break;
            case 3: /* ipv6NetToMediaType */
                if (IP_BIT_ISSET(routewalk.bestrt->hdr.flags, IPNET_RTF_STATIC))
                    ret = ipsnmp_util_put_integer(magic, iid, 3);   /* static */
                else
                    ret = ipsnmp_util_put_integer(magic, iid, 2);   /* dynamic */
                break;
            case 4: /* ipv6IfNetToMediaState */
                nc = IPNET_IP6_NC(routewalk.bestrt);
                ip_assert(nc != IP_NULL);
                switch(nc->state)
                {
                    case IPNET_ND_REACHABLE :
                        state = 1;  /* reachable */
                        break;
                    case IPNET_ND_STALE :
                        state = 2;  /* stale */
                        break;
                    case IPNET_ND_DELAY :
                        state = 3;  /* delay */
                        break;
                    case IPNET_ND_PROBE :
                        state = 4;  /* probe */
                        break;
                    default:
                        state = 6;  /* unknown */
                        break;
                }
                ret = ipsnmp_util_put_integer(magic, iid, state);
                break;
            case 5: /* ipv6IfNetToMediaLastUpdated */
                ret = ipsnmp_util_put_timeticks(magic, iid, 0);
                break;
            case 6: /* ipv6NetToMediaValid */
                ret = ipsnmp_util_put_integer(magic, iid, 1);   /* true */
                break;
            default:
                IP_PANIC();
                ret = IPSNMP_ERROR_GENERROR;
                break;
        }

        ipcom_free(iid);
    }

    if (cmd == IPSNMP_MIB_COMMAND_TEST || cmd == IPSNMP_MIB_COMMAND_SET)
    {
        switch(lid)
        {
            case 6: /* ipv6NetToMediaValid */
                ret = ipsnmp_util_get_integer(vb, &ipv6NetToMediaValid);
                if (ret == IPSNMP_ERROR_NOERROR)
                {
                    if (ipv6NetToMediaValid != 2)
                    {
                        ret = IPSNMP_ERROR_WRONGVALUE;
                    }
                }

                if (ret == IPSNMP_ERROR_NOERROR && cmd == IPSNMP_MIB_COMMAND_SET)
                {
                    /* Remove the NDP entry */
                    ipcom_memset(&tag, 0, sizeof(tag));
                    IPCOM_SA_LEN_SET(&tag.addr, sizeof(struct Ip_sockaddr_in6));
                    tag.addr.sin6_family = IP_AF_INET6;
                    tag.addr.sin6_scope_id = routewalk.bestrt->netif->ipcom.ifindex;
                    ipcom_memcpy(&tag.addr.sin6_addr, routewalk.bestrt->hdr.key, sizeof(tag.addr.sin6_addr));
                    tag.hdr.type   = IPNET_CTRL_DEL_NC_ENTRY;
                    tag.hdr.size   = sizeof(tag);
                    tag.vr_index   = 0;
                    if (ipnet_ctrl_islocked(&tag.hdr) < 0)
                    {
                        IPCOM_LOG1(ERR, "Failed to remove ndp entry: %s", ipcom_strerror(ipcom_errno));
                        ret = IPSNMP_ERROR_GENERROR;
                    }
                }
                break;
            default:
                IP_PANIC();
                ret = IPSNMP_ERROR_GENERROR;
                break;
        }
    }

exit:
    if (buf != IP_NULL)
        ipcom_free(buf);
    if (best != IP_NULL)
        ipcom_free(best);
    return ret;
}


/*
 ****************************************************************************
 * 10                    GLOBAL FUNCTIONS
 ****************************************************************************
 */

/*
 ****************************************************************************
 * 11                    PUBLIC FUNCTIONS
 ****************************************************************************
 */

/*
 *===========================================================================
 *                      ipnet_ipv6_mib_init
 *===========================================================================
 * Description: Initializes IPV6-MIB
 * Parameters: None
 * Returns: IPCOM_SUCCESS or IPCOM_ERR_FAILED
 *
 */
IP_PUBLIC Ip_err
ipnet_ipv6_mib_init(void)
{
    struct Ipsnmp_node_object nodeobj;
    Ip_s32 ret;

    /* Assign lock function */
    nodeobj.lock = ipnet_ipv6_mib_lock;

    /* Add node "ipv6MIB" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6MIB";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6MIBObjects" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6MIBObjects";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6Notifications" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.2";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6Notifications";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6NotificationPrefix" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.2.0";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6NotificationPrefix";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6Conformance" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.3";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6Conformance";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6Compliances" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.3.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6Compliances";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6Groups" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.3.2";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6Groups";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6Forwarding" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READWRITE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ipv6_mib_handler_scalars;
    nodeobj.id = "1.3.6.1.2.1.55.1.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6Forwarding";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6DefaultHopLimit" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READWRITE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ipv6_mib_handler_scalars;
    nodeobj.id = "1.3.6.1.2.1.55.1.2";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6DefaultHopLimit";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6Interfaces" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_GAUGE32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6Interfaces;
    nodeobj.id = "1.3.6.1.2.1.55.1.3";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6Interfaces";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfTableLastChange" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_TIMETICKS;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.55.1.4";
    nodeobj.instance = &ipnet->mib2.ipv6IfTableLastChange;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfTableLastChange";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfTable" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.5";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfTable";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfEntry" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.5.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfEntry";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIndex" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.5.1.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIndex";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfDescr" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READWRITE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_OCTETSTRING;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.5.1.2";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfDescr";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfLowerLayer" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_OID;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.5.1.3";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfLowerLayer";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfEffectiveMtu" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_GAUGE32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.5.1.4";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfEffectiveMtu";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfReasmMaxSize" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_GAUGE32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.5.1.5";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfReasmMaxSize";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIdentifier" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READWRITE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_OCTETSTRING;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.5.1.6";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIdentifier";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfIdentifierLength" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READWRITE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.5.1.7";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfIdentifierLength";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfPhysicalAddress" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_OCTETSTRING;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.5.1.8";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfPhysicalAddress";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfAdminStatus" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READWRITE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.5.1.9";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfAdminStatus";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfOperStatus" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.5.1.10";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfOperStatus";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfLastChange" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_TIMETICKS;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.5.1.11";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfLastChange";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsTable" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.6";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsTable";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsEntry" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsEntry";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsInReceives" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsInReceives";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsInHdrErrors" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.2";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsInHdrErrors";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsInTooBigErrors" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.3";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsInTooBigErrors";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsInNoRoutes" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.4";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsInNoRoutes";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsInAddrErrors" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.5";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsInAddrErrors";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsInUnknownProtos" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.6";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsInUnknownProtos";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsInTruncatedPkts" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.7";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsInTruncatedPkts";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsInDiscards" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.8";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsInDiscards";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsInDelivers" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.9";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsInDelivers";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsOutForwDatagrams" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.10";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsOutForwDatagrams";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsOutRequests" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.11";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsOutRequests";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsOutDiscards" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.12";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsOutDiscards";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsOutFragOKs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.13";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsOutFragOKs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsOutFragFails" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.14";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsOutFragFails";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsOutFragCreates" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.15";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsOutFragCreates";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsReasmReqds" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.16";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsReasmReqds";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsReasmOKs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.17";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsReasmOKs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsReasmFails" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.18";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsReasmFails";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsInMcastPkts" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.19";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsInMcastPkts";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStatsOutMcastPkts" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6IfStatsTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.6.1.20";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStatsOutMcastPkts";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6AddrPrefixTable" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.7";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6AddrPrefixTable";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6AddrPrefixEntry" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.7.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6AddrPrefixEntry";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6AddrPrefix" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_OCTETSTRING;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.7.1.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6AddrPrefix";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6AddrPrefixLength" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.7.1.2";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6AddrPrefixLength";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6AddrPrefixOnLinkFlag" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6AddrPrefixTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.7.1.3";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6AddrPrefixOnLinkFlag";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6AddrPrefixAutonomousFlag" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6AddrPrefixTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.7.1.4";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6AddrPrefixAutonomousFlag";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6AddrPrefixAdvPreferredLifetime" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_GAUGE32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6AddrPrefixTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.7.1.5";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6AddrPrefixAdvPreferredLifetime";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6AddrPrefixAdvValidLifetime" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_GAUGE32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6AddrPrefixTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.7.1.6";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6AddrPrefixAdvValidLifetime";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6AddrTable" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.8";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6AddrTable";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6AddrEntry" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.8.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6AddrEntry";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6AddrAddress" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_OCTETSTRING;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.8.1.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6AddrAddress";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6AddrPfxLength" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6AddrTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.8.1.2";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6AddrPfxLength";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6AddrType" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6AddrTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.8.1.3";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6AddrType";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6AddrAnycastFlag" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6AddrTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.8.1.4";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6AddrAnycastFlag";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6AddrStatus" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6AddrTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.8.1.5";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6AddrStatus";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6RouteNumber" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_GAUGE32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6RouteNumber;
    nodeobj.id = "1.3.6.1.2.1.55.1.9";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6RouteNumber";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6DiscardedRoutes" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.55.1.10";
    nodeobj.instance = &ipnet->mib2.ipv6DiscardedRoutes;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6DiscardedRoutes";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6RouteTable" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.11";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6RouteTable";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6RouteEntry" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.11.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6RouteEntry";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6RouteDest" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_OCTETSTRING;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.11.1.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6RouteDest";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6RoutePfxLength" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.11.1.2";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6RoutePfxLength";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6RouteIndex" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_GAUGE32;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.11.1.3";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6RouteIndex";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6RouteIfIndex" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6RouteTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.11.1.4";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6RouteIfIndex";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6RouteNextHop" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_OCTETSTRING;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6RouteTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.11.1.5";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6RouteNextHop";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6RouteType" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6RouteTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.11.1.6";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6RouteType";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6RouteProtocol" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6RouteTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.11.1.7";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6RouteProtocol";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6RoutePolicy" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6RouteTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.11.1.8";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6RoutePolicy";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6RouteAge" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_GAUGE32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6RouteTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.11.1.9";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6RouteAge";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6RouteNextHopRDI" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_GAUGE32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6RouteTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.11.1.10";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6RouteNextHopRDI";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6RouteMetric" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_GAUGE32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6RouteTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.11.1.11";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6RouteMetric";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6RouteWeight" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_GAUGE32;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6RouteTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.11.1.12";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6RouteWeight";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6RouteInfo" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_OID;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6RouteTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.11.1.13";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6RouteInfo";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6RouteValid" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READWRITE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6RouteTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.11.1.14";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6RouteValid";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6NetToMediaTable" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.12";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6NetToMediaTable";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6NetToMediaEntry" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.12.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6NetToMediaEntry";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6NetToMediaNetAddress" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_OCTETSTRING;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.1.12.1.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6NetToMediaNetAddress";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6NetToMediaPhysAddress" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_OCTETSTRING;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6NetToMediaTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.12.1.2";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6NetToMediaPhysAddress";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6NetToMediaType" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6NetToMediaTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.12.1.3";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6NetToMediaType";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfNetToMediaState" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6NetToMediaTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.12.1.4";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfNetToMediaState";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfNetToMediaLastUpdated" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_TIMETICKS;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6NetToMediaTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.12.1.5";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfNetToMediaLastUpdated";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6NetToMediaValid" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READWRITE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ipv6_mib_handler_ipv6NetToMediaTable;
    nodeobj.id = "1.3.6.1.2.1.55.1.12.1.6";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6NetToMediaValid";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6IfStateChange" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.2.0.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6IfStateChange";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_TRAP;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6GeneralGroup" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.3.2.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6GeneralGroup";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6NotificationGroup" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.3.2.2";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6NotificationGroup";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipv6Compliance" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.55.3.1.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipv6Compliance";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if (ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    return IPCOM_SUCCESS;
}

#endif /* #if defined(IPCOM_USE_MIB2) && defined(IPCOM_USE_INET6) */
#endif /* #ifdef IPSNMP */

#if !defined(IPSNMP) || !defined(IPCOM_USE_MIB2)
void ipnet_ipv6_mib_empty_file(void);
void ipnet_ipv6_mib_empty_file(void) { }
#endif


/*
 ****************************************************************************
 *                     END OF FILE
 ****************************************************************************
 */

