/*
 ******************************************************************************
 *                     INTERPEAK SOURCE FILE
 *
 *   Document no: @(#) $Name: VXWORKS_ITER18A_FRZ10 $ $RCSfile: ipnet_ip_forward_mib.c,v $ $Revision: 1.20 $
 *   $Source: /home/interpeak/CVSRoot/ipnet2/src/ipnet_ip_forward_mib.c,v $
 *   $Author: kenneth $
 *   $State: Exp $ $Locker:  $
 *
 *   INTERPEAK_COPYRIGHT_STRING
 *   Design and implementation by Markus Carlstedt <markus@interpeak.se>
 ******************************************************************************
 */

/*
 ****************************************************************************
 * 1                    DESCRIPTION
 ****************************************************************************
 */

/*
 *===========================================================================
 *                      IP-FORWARD-MIB
 *===========================================================================
 *
 * Autogenerated by 'ipmibc' with 'smidump 0.4.1' on 2003-11-25 at 14:50:41
 *
 * This file includes initialization code and stubs for all MIB variables in
 * IP-FORWARD-MIB. Without any changes it should compile and run with the
 * behaviour that GetRequests succeed with the returned value being
 * zero. SetRequests also succeed but without any actual variables
 * being updated.
 *
 * Modifications to this file are necessary in order to enable read and
 * write operations on actual variables presented in the MIB interface.
 * Each segment in the code where a change is proposed is marked with a
 * 'MIB_TODO' comment together with a pseudo code example describing the
 * modification.
 *
 * This file shall normally be compiled together with the product to which
 * SNMP support is to be added and then linked with the IPSNMP libraries.
 * The MIB is initialized by calling the public initialization function defined
 * at the end of this file. Since no header files are generated its function
 * prototype should be copied into the the product that initializes the MIB.
 *
 */

/*
 ****************************************************************************
 * 2                    CONFIGURATION
 ****************************************************************************
 */

#ifndef IPCOM_KERNEL
#define IPCOM_KERNEL
#endif
#include "ipnet_config.h"


/*
 ****************************************************************************
 * 3                    INCLUDE FILES
 ****************************************************************************
 */

#define IPCOM_USE_CLIB_PROTO
#include <ipcom_clib.h>
#include <ipcom_cstyle.h>
#include <ipcom_err.h>
#include <ipcom_route.h>
#include <ipcom_syslog.h>
#include <ipcom_type.h>

#ifdef IPSNMP
#include <ipnet_h.h>
#include <ipnet_loopback.h>
#include <ipsnmp.h>
#include <ipsnmp_config.h>

#if defined(IPCOM_USE_MIB2) && defined(IPCOM_USE_INET)


/*
 ****************************************************************************
 * 4                    DEFINES
 ****************************************************************************
 */

#ifdef IPCOM_SYSLOG_FACILITY
#undef IPCOM_SYSLOG_FACILITY
#endif
#define IPCOM_SYSLOG_FACILITY    IPCOM_LOG_IPSNMP

#ifdef IPCOM_SYSLOG_PRIORITY
#undef IPCOM_SYSLOG_PRIORITY
#endif
#define IPCOM_SYSLOG_PRIORITY    IPCOM_LOG_DEBUG


/*
 ****************************************************************************
 * 5                    TYPES
 ****************************************************************************
 */

typedef struct Ipsnmp_route_walk_struct
{
    Ip_s32 cmd;
    char *id;
    char *buf;
    char *best;
    Ipnet_route_entry *bestrt;
    Ip_bool count_only;
}
Ipsnmp_route_walk;


/*
 ****************************************************************************
 * 6                    EXTERNAL PROTOTYPES
 ****************************************************************************
 */

/*
 ****************************************************************************
 * 7                    LOCAL PROTOTYPES
 ****************************************************************************
 */

IP_PUBLIC Ip_err ipnet_ip_forward_mib_init(void);


/*
 ****************************************************************************
 * 8                    DATA
 ****************************************************************************
 */

IP_STATIC Ip_u32 count;
IP_STATIC Ipsnmp_route_walk routewalk;


/*
 ****************************************************************************
 * 9                    STATIC FUNCTIONS
 ****************************************************************************
 */

/*
 *===========================================================================
 *                      ipnet_ip_forward_mib_lock
 *===========================================================================
 * Description: Protects MIB variables in SNMPv2-MIB from multiple access
 * Parameters: lock - boolean that controls lock or unlock
 * Returns: Nothing
 *
 */
IP_STATIC void
ipnet_ip_forward_mib_lock(Ip_bool lock)
{
    if(lock == IP_TRUE)
    {
        IPNET_CODE_LOCK_WRITE();
    }
    else
    {
        IPNET_CODE_UNLOCK();
    }
}


/*
 *===========================================================================
 *                      ipnet_ip_mib_cb_ipCidrRouteTable
 *===========================================================================
 * Description:
 * Parameters:
 * Returns:
 *
 */
IP_STATIC Ip_bool
ipnet_ip_mib_cb_ipCidrRouteTable(Ipnet_route_entry *rt, Ipsnmp_route_walk *rwp)
{
    Ip_s32 tmp, lex, len = 0;

    /* Early exit if exact match was found previously */
    if(rwp->bestrt != IP_NULL &&
        (rwp->cmd == IPSNMP_MIB_COMMAND_GET
        || rwp->cmd == IPSNMP_MIB_COMMAND_TEST
        || rwp->cmd == IPSNMP_MIB_COMMAND_SET))
        goto exit;

    if(rt->netif == IP_NULL)
        goto exit;

    /* Do not use hidden entries */
    if(IP_BIT_ISSET(rt->hdr.flags, IPNET_RTF_X_HIDDEN))
        goto exit;

    /* Route must be usable */
    if(IP_BIT_ISFALSE(rt->hdr.flags, IPNET_RTF_UP))
        goto exit;

    /* Do not use link layer entries */
    if(IP_BIT_ISSET(rt->hdr.flags, IPNET_RTF_LLINFO))
        goto exit;

    /* Do not use loopback entries */
    if (IP_BIT_ISSET(rt->netif->ipcom.flags, IP_IFF_LOOPBACK))
        goto exit;

    ip_assert(rt->hdr.key != IP_NULL);

    /* Do not use multicast entries */
    if(IP_IN_CLASSD(*(Ip_u32 *)rt->hdr.key))
        goto exit;

    /* Do not use broadcast entries */
    if(ip_ntohl(*(Ip_u32 *)rt->hdr.key) == IP_INADDR_BROADCAST)
        goto exit;

    if(rwp->count_only == IP_TRUE)
    {
        count++;
        goto exit;
    }

    rwp->buf[0] = '\0';
    /* ipCidrRouteDest */
    if(ipcom_inet_ntop(IP_AF_INET, rt->hdr.key, &rwp->buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len) == IP_NULL)
        goto exit;
    len = ipcom_strlen(rwp->buf);
    if(ipcom_snprintf(&rwp->buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, ".") < 0)
        goto exit;
    len = ipcom_strlen(rwp->buf);

    /* ipCidrRouteMask */
    if(rt->hdr.mask == IP_NULL)
    {
        if(ipcom_snprintf(&rwp->buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, "255.255.255.255") < 0)
            goto exit;
    }
    else
    {
        if(ipcom_inet_ntop(IP_AF_INET, rt->hdr.mask, &rwp->buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len) == IP_NULL)
            goto exit;
    }
    len = ipcom_strlen(rwp->buf);
    if(ipcom_snprintf(&rwp->buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, ".") < 0)
        goto exit;
    len = ipcom_strlen(rwp->buf);

    /* ipCidrRouteTos */
    tmp = 0;
    if(ipcom_snprintf(&rwp->buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, "%d.", (int)tmp) < 0)
        goto exit;
    len = ipcom_strlen(rwp->buf);

    /* ipCidrRouteNextHop */
    if(IP_BIT_ISSET(rt->hdr.flags, IPNET_RTF_GATEWAY))
    {
        struct Ip_sockaddr_in *sa;

        ip_assert(rt->gateway != IP_NULL);
        sa = (struct Ip_sockaddr_in *)rt->gateway;
        if(ipcom_inet_ntop(IP_AF_INET, &sa->sin_addr.s_addr, &rwp->buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID - len) == IP_NULL)
            goto exit;
    }
    else
    {
        if(ipcom_snprintf(&rwp->buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, "0.0.0.0") < 0)
            goto exit;
    }
    len = ipcom_strlen(rwp->buf);
    if(ipcom_snprintf(&rwp->buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, ".") < 0)
        goto exit;
    len = ipcom_strlen(rwp->buf);
    if(len)
        rwp->buf[len-1] = '\0';

    lex = ipsnmp_util_lexcmp_oid(rwp->buf, rwp->id);
    if(rwp->cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        if(lex > 0)
        {
            if(rwp->bestrt == IP_NULL || ipsnmp_util_lexcmp_oid(rwp->buf, rwp->best) < 0)
            {
                ipcom_strcpy(rwp->best, rwp->buf);
                rwp->bestrt = rt;
            }
        }
    }
    else
    {
        if(lex == 0)
        {
            ipcom_strcpy(rwp->best, rwp->buf);
            rwp->bestrt = rt;
        }
    }

exit:
    /* Do not delete the entry */
    return IP_FALSE;
}


/*
 *===========================================================================
 *                      ipnet_ip_forward_mib_table_search_ipCidrRouteTable
 *===========================================================================
 * Description: Searches ipCidrRouteTable for a matching entry
 * Parameters: id, buf, best, cmd
 * Returns: Row index of the found entry OR -1 if not found OR -2 for error
 *
 */
IP_STATIC Ip_s32
ipnet_ip_forward_mib_table_search_ipCidrRouteTable(char *id,
                                                   char *buf,
                                                   char *best,
                                                   Ip_s32 cmd)
{
    Ipcom_route *rtab;

    if (ipnet_route_get_rtab(IP_AF_INET, 0, IPCOM_ROUTE_TABLE_DEFAULT, &rtab) < 0)
        return -1;

    routewalk.cmd = cmd;
    routewalk.id = id;
    routewalk.buf = buf;
    routewalk.best = best;
    routewalk.bestrt = IP_NULL;
    routewalk.count_only = IP_FALSE;

    /* For now handle only the default route table */
    ipcom_route_walk_tree(rtab,
                          (Ip_bool(*)(Ipcom_route_entry *, void *))
                          ipnet_ip_mib_cb_ipCidrRouteTable, &routewalk);

    if(routewalk.bestrt == IP_NULL)
        return -1;
    return 0;
}


/*
 *===========================================================================
 *                      ipnet_ip_forward_mib_handler_ipCidrRouteNumber
 *===========================================================================
 * Description: MIB handler for ipCidrRouteNumber
 * Parameters: See file 'ipsnmp.h'
 * Returns: IPSNMP_ERROR_XXX
 *
 */
IP_STATIC Ip_s32
ipnet_ip_forward_mib_handler_ipCidrRouteNumber(Ip_s32 cmd,
                                               char *id,
                                               Ipsnmp_varbind *vb,
                                               Ip_s32 magic,
                                               struct Ipsnmp_node_object *nodeobj)
{
    Ip_s32       ret = -1;
    Ip_u32       ipCidrRouteNumber;
    char        *iid;
    Ipcom_route *rtab;

    (void)id;
    (void)vb;
    if (cmd == IPSNMP_MIB_COMMAND_GET || cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        iid = ipsnmp_create_iid_integer(nodeobj->id, 0);
        if (iid == IP_NULL)
            return IPSNMP_ERROR_GENERROR;

        if (ipnet_route_get_rtab(IP_AF_INET, 0, IPCOM_ROUTE_TABLE_DEFAULT, &rtab) < 0)
            return IPSNMP_ERROR_GENERROR;


        routewalk.cmd = cmd;
        routewalk.id = IP_NULL;
        routewalk.buf = IP_NULL;
        routewalk.best = IP_NULL;
        routewalk.bestrt = IP_NULL;
        routewalk.count_only = IP_TRUE;
        count = 0;
        /* For now handle only the default route table */
        ipcom_route_walk_tree(rtab,
                              (Ip_bool(*)(Ipcom_route_entry *, void *))
                              ipnet_ip_mib_cb_ipCidrRouteTable, &routewalk);
        ipCidrRouteNumber = count;

        ret = ipsnmp_util_put_gauge32(magic, iid, ipCidrRouteNumber);
        ipcom_free(iid);
    }

    return ret;
}


/*
 *===========================================================================
 *                      ipnet_ip_forward_mib_handler_ipCidrRouteTable
 *===========================================================================
 * Description: MIB handler for ipCidrRouteDest
 * Parameters: See file 'ipsnmp.h'
 * Returns: IPSNMP_ERROR_XXX
 *
 */
IP_STATIC Ip_s32
ipnet_ip_forward_mib_handler_ipCidrRouteTable(Ip_s32 cmd,
                                              char *id,
                                              Ipsnmp_varbind *vb,
                                              Ip_s32 magic,
                                              struct Ipsnmp_node_object *nodeobj)
{
    Ip_s32 lid, bestindex, ret = -1;
    char *iid;
    char *buf = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    char *best = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);

    if(buf == IP_NULL || best == IP_NULL)
    {
        ret = IPSNMP_ERROR_GENERROR;
        goto exit;
    }

    lid = ipsnmp_util_last_subid(nodeobj->id);
    ip_assert(lid >= 1 && lid <= 16);
    bestindex = ipnet_ip_forward_mib_table_search_ipCidrRouteTable(id, buf, best, cmd);
    if(bestindex == -2)
    {
        ret = IPSNMP_ERROR_GENERROR;
        goto exit;
    }
    else if(bestindex == -1)
    {
        ret = IPSNMP_ERROR_NOSUCHNAME;
        goto exit;
    }

    if(cmd == IPSNMP_MIB_COMMAND_GET || cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        iid = ipsnmp_create_iid_direct(nodeobj->id, best);
        if(iid == IP_NULL)
        {
            ret = IPSNMP_ERROR_GENERROR;
            goto exit;
        }

        ip_assert(routewalk.bestrt != IP_NULL);
        switch(lid)
        {
            case 1: /* ipCidrRouteDest */
                ret = ipsnmp_util_put_ipaddress(magic, iid, ip_ntohl(*(Ip_u32 *)routewalk.bestrt->hdr.key));
                break;
            case 2: /* ipCidrRouteMask */
                if(routewalk.bestrt->hdr.mask != IP_NULL)
                    ret = ipsnmp_util_put_ipaddress(magic, iid, ip_ntohl(*(Ip_u32 *)routewalk.bestrt->hdr.mask));
                else
                    ret = ipsnmp_util_put_ipaddress(magic, iid, 0xffffffff);
                break;
            case 3: /* ipCidrRouteTos */
                ret = ipsnmp_util_put_integer(magic, iid, 0);
                break;
            case 4: /* ipCidrRouteNextHop */
                if(IP_BIT_ISSET(routewalk.bestrt->hdr.flags, IPNET_RTF_GATEWAY))
                {
                    struct Ip_sockaddr_in *sa = (struct Ip_sockaddr_in *)routewalk.bestrt->gateway;
                    ret = ipsnmp_util_put_ipaddress(magic, iid, ip_ntohl(sa->sin_addr.s_addr));
                }
                else
                    ret = ipsnmp_util_put_ipaddress(magic, iid, 0);
                break;
            case 5: /* ipCidrRouteIfIndex */
                ret = ipsnmp_util_put_integer(magic, iid, routewalk.bestrt->netif->ipcom.ifindex);
                break;
            case 6: /* ipCidrRouteType */
                if(IP_BIT_ISSET(routewalk.bestrt->hdr.flags, IPNET_RTF_GATEWAY))
                    ret = ipsnmp_util_put_integer(magic, iid, 4);   /* remote */
                else
                    ret = ipsnmp_util_put_integer(magic, iid, 3);   /* local */
                break;
            case 7: /* ipCidrRouteProto */
                ret = ipsnmp_util_put_integer(magic, iid, 2);   /* local */
                break;
            case 8: /* ipCidrRouteAge */
                ret = ipsnmp_util_put_integer(magic, iid, 0);
                break;
            case 9: /* ipCidrRouteInfo */
                ret = ipsnmp_util_put_oid(magic, iid, "0.0");
                break;
            case 10: /* ipCidrRouteNextHopAS */
                ret = ipsnmp_util_put_integer(magic, iid, 0);
                break;
            case 11: /* ipCidrRouteMetric1 */
                ret = ipsnmp_util_put_integer(magic, iid, -1);
                break;
            case 12: /* ipCidrRouteMetric2 */
                ret = ipsnmp_util_put_integer(magic, iid, -1);
                break;
            case 13: /* ipCidrRouteMetric3 */
                ret = ipsnmp_util_put_integer(magic, iid, -1);
                break;
            case 14: /* ipCidrRouteMetric4 */
                ret = ipsnmp_util_put_integer(magic, iid, -1);
                break;
            case 15: /* ipCidrRouteMetric5 */
                ret = ipsnmp_util_put_integer(magic, iid, -1);
                break;
            case 16: /* ipCidrRouteStatus */
                ret = ipsnmp_util_put_integer(magic, iid, 1);   /* active */
                break;
            default:
                IP_PANIC();
                ret = IPSNMP_ERROR_GENERROR;
                break;
        }

        ipcom_free(iid);
    }

    if(cmd == IPSNMP_MIB_COMMAND_TEST || cmd == IPSNMP_MIB_COMMAND_SET)
    {
        (void)vb;
        switch(lid)
        {
            case 5: /* ipCidrRouteIfIndex */
            case 6: /* ipCidrRouteType */
            case 9: /* ipCidrRouteInfo */
            case 10: /* ipCidrRouteNextHopAS */
            case 11: /* ipCidrRouteMetric1 */
            case 12: /* ipCidrRouteMetric2 */
            case 13: /* ipCidrRouteMetric3 */
            case 14: /* ipCidrRouteMetric4 */
            case 15: /* ipCidrRouteMetric5 */
            case 16: /* ipCidrRouteStatus */
                ret = IPSNMP_ERROR_NOSUCHNAME;
                break;
            default:
                IP_PANIC();
                ret = IPSNMP_ERROR_GENERROR;
                break;
        }
    }

exit:
    if(buf != IP_NULL)
        ipcom_free(buf);
    if(best != IP_NULL)
        ipcom_free(best);
    return ret;
}


/*
 ****************************************************************************
 * 10                    GLOBAL FUNCTIONS
 ****************************************************************************
 */

/*
 ****************************************************************************
 * 11                    PUBLIC FUNCTIONS
 ****************************************************************************
 */

/*
 *===========================================================================
 *                      ipnet_ip_forward_mib_init
 *===========================================================================
 * Description: Initializes IP-FORWARD-MIB
 * Parameters: None
 * Returns: IPCOM_SUCCESS or IPCOM_ERR_FAILED
 *
 */
IP_PUBLIC Ip_err
ipnet_ip_forward_mib_init(void)
{
    struct Ipsnmp_node_object nodeobj;
    Ip_s32 ret;

    /* Assign lock function */
    nodeobj.lock = ipnet_ip_forward_mib_lock;

    /* Add node "ipForward" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.4.24";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipForward";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipForwardConformance" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.4.24.5";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipForwardConformance";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipForwardGroups" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.4.24.5.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipForwardGroups";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipForwardCompliances" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.4.24.5.2";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipForwardCompliances";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipCidrRouteNumber" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_GAUGE32;
    nodeobj.handler = ipnet_ip_forward_mib_handler_ipCidrRouteNumber;
    nodeobj.id = "1.3.6.1.2.1.4.24.3";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipCidrRouteNumber";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipCidrRouteTable" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.4.24.4";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipCidrRouteTable";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipCidrRouteEntry" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.4.24.4.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipCidrRouteEntry";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipCidrRouteDest" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_IPADDRESS;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.4.24.4.1.1";
    /* nodeobj.instance = IP_NULL; */
    nodeobj.handler = ipnet_ip_forward_mib_handler_ipCidrRouteTable;
#ifdef IP_DEBUG
    nodeobj.name = "ipCidrRouteDest";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipCidrRouteMask" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_IPADDRESS;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.4.24.4.1.2";
    /* nodeobj.instance = IP_NULL; */
    nodeobj.handler = ipnet_ip_forward_mib_handler_ipCidrRouteTable;
#ifdef IP_DEBUG
    nodeobj.name = "ipCidrRouteMask";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipCidrRouteTos" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ip_forward_mib_handler_ipCidrRouteTable;
    nodeobj.id = "1.3.6.1.2.1.4.24.4.1.3";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipCidrRouteTos";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipCidrRouteNextHop" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_IPADDRESS;
    nodeobj.handler = ipnet_ip_forward_mib_handler_ipCidrRouteTable;
    nodeobj.id = "1.3.6.1.2.1.4.24.4.1.4";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipCidrRouteNextHop";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipCidrRouteIfIndex" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READCREATE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ip_forward_mib_handler_ipCidrRouteTable;
    nodeobj.id = "1.3.6.1.2.1.4.24.4.1.5";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipCidrRouteIfIndex";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipCidrRouteType" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READCREATE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ip_forward_mib_handler_ipCidrRouteTable;
    nodeobj.id = "1.3.6.1.2.1.4.24.4.1.6";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipCidrRouteType";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipCidrRouteProto" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ip_forward_mib_handler_ipCidrRouteTable;
    nodeobj.id = "1.3.6.1.2.1.4.24.4.1.7";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipCidrRouteProto";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipCidrRouteAge" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ip_forward_mib_handler_ipCidrRouteTable;
    nodeobj.id = "1.3.6.1.2.1.4.24.4.1.8";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipCidrRouteAge";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipCidrRouteInfo" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READCREATE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_OID;
    nodeobj.handler = ipnet_ip_forward_mib_handler_ipCidrRouteTable;
    nodeobj.id = "1.3.6.1.2.1.4.24.4.1.9";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipCidrRouteInfo";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipCidrRouteNextHopAS" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READCREATE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ip_forward_mib_handler_ipCidrRouteTable;
    nodeobj.id = "1.3.6.1.2.1.4.24.4.1.10";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipCidrRouteNextHopAS";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipCidrRouteMetric1" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READCREATE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ip_forward_mib_handler_ipCidrRouteTable;
    nodeobj.id = "1.3.6.1.2.1.4.24.4.1.11";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipCidrRouteMetric1";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipCidrRouteMetric2" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READCREATE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ip_forward_mib_handler_ipCidrRouteTable;
    nodeobj.id = "1.3.6.1.2.1.4.24.4.1.12";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipCidrRouteMetric2";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipCidrRouteMetric3" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READCREATE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ip_forward_mib_handler_ipCidrRouteTable;
    nodeobj.id = "1.3.6.1.2.1.4.24.4.1.13";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipCidrRouteMetric3";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipCidrRouteMetric4" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READCREATE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ip_forward_mib_handler_ipCidrRouteTable;
    nodeobj.id = "1.3.6.1.2.1.4.24.4.1.14";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipCidrRouteMetric4";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipCidrRouteMetric5" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READCREATE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ip_forward_mib_handler_ipCidrRouteTable;
    nodeobj.id = "1.3.6.1.2.1.4.24.4.1.15";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipCidrRouteMetric5";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipCidrRouteStatus" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READCREATE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ip_forward_mib_handler_ipCidrRouteTable;
    nodeobj.id = "1.3.6.1.2.1.4.24.4.1.16";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipCidrRouteStatus";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipForwardMultiPathGroup" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.4.24.5.1.2";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipForwardMultiPathGroup";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipForwardCidrRouteGroup" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.4.24.5.1.3";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipForwardCidrRouteGroup";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipForwardCompliance" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.4.24.5.2.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipForwardCompliance";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipForwardOldCompliance" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.4.24.5.2.2";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipForwardOldCompliance";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    return IPCOM_SUCCESS;
}

#endif /* #if defined(IPCOM_USE_MIB2) && defined(IPCOM_USE_INET) */
#endif /* #ifdef IPSNMP */

#if !defined(IPSNMP) || !defined(IPCOM_USE_MIB2)
void ipnet_ip_forward_mib_empty_file(void);
void ipnet_ip_forward_mib_empty_file(void) { }
#endif


/*
 ****************************************************************************
 *                     END OF FILE
 ****************************************************************************
 */

