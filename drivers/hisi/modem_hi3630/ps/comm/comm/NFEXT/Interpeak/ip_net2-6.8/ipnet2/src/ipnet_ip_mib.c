/*
 ******************************************************************************
 *                     INTERPEAK SOURCE FILE
 *
 *   Document no: @(#) $Name: VXWORKS_ITER18A_FRZ10 $ $RCSfile: ipnet_ip_mib.c,v $ $Revision: 1.38 $
 *   $Source: /home/interpeak/CVSRoot/ipnet2/src/ipnet_ip_mib.c,v $
 *   $Author: jhorteli $
 *   $State: Exp $ $Locker:  $
 *
 *   INTERPEAK_COPYRIGHT_STRING
 *   Design and implementation by Markus Carlstedt <markus@interpeak.se>
 ******************************************************************************
 */

/*
 ****************************************************************************
 * 1                    DESCRIPTION
 ****************************************************************************
 */

/*
 *===========================================================================
 *                      IP-MIB
 *===========================================================================
 *
 * Autogenerated by 'ipmibc' with 'smidump 0.4.1' on 2003-11-24 at 13:37:51
 *
 * This file includes initialization code and stubs for MIB variables defined
 * in IP-MIB. Without any changes it should compile and run with the
 * behaviour that GetRequests succeed with the returned value being
 * zero. SetRequests also succeed but without any actual variables
 * being updated.
 *
 * Modifications to this file are necessary in order to enable read and
 * write operations on actual variables presented in the MIB interface.
 * Each segment in the code where a change is proposed is marked with a
 * 'MIB_TODO' comment together with a pseudo code example describing the
 * modification.
 *
 * This file shall normally be compiled together with the product to which
 * SNMP support is to be added and then linked with the IPSNMP libraries.
 * The MIB is initialized by calling the public initialization function defined
 * at the end of this file. Since no header files are generated its function
 * prototype should be copied into the the product that initializes the MIB.
 *
 */

/*
 ****************************************************************************
 * 2                    CONFIGURATION
 ****************************************************************************
 */

#ifndef IPCOM_KERNEL
#define IPCOM_KERNEL
#endif
#include "ipnet_config.h"


/*
 ****************************************************************************
 * 3                    INCLUDE FILES
 ****************************************************************************
 */

#define IPCOM_USE_CLIB_PROTO
#include <ipcom_type.h>
#include <ipcom_cstyle.h>
#include <ipcom_clib.h>
#include <ipcom_syslog.h>
#include <ipcom_err.h>

#ifdef IPSNMP
#include <ipnet_h.h>
#include <ipnet_usr_sock.h>
#include <ipsnmp.h>
#include <ipsnmp_config.h>

#if defined(IPCOM_USE_MIB2) && defined(IPCOM_USE_INET)


/*
 ****************************************************************************
 * 4                    DEFINES
 ****************************************************************************
 */

#ifdef IPCOM_SYSLOG_FACILITY
#undef IPCOM_SYSLOG_FACILITY
#endif
#define IPCOM_SYSLOG_FACILITY    IPCOM_LOG_IPSNMP

#ifdef IPCOM_SYSLOG_PRIORITY
#undef IPCOM_SYSLOG_PRIORITY
#endif
#define IPCOM_SYSLOG_PRIORITY    IPCOM_LOG_DEBUG


/*
 ****************************************************************************
 * 5                    TYPES
 ****************************************************************************
 */

typedef struct Ipsnmp_route_walk_struct
{
    Ip_s32 cmd;
    char *id;
    char *buf;
    char *best;
    Ipnet_route_entry *bestrt;
    Ip_bool count_only;
}
Ipsnmp_route_walk;


/*
 ****************************************************************************
 * 6                    EXTERNAL PROTOTYPES
 ****************************************************************************
 */

/*
 ****************************************************************************
 * 7                    LOCAL PROTOTYPES
 ****************************************************************************
 */

IP_PUBLIC Ip_err ipnet_ip_mib_init(void);


/*
 ****************************************************************************
 * 8                    DATA
 ****************************************************************************
 */

IP_STATIC struct Ipnet_ip4_addr_entry_struct *bestaddr;
IP_STATIC Ipsnmp_route_walk routewalk;

/*
 ****************************************************************************
 * 9                    STATIC FUNCTIONS
 ****************************************************************************
 */

/*
 *===========================================================================
 *                      ipnet_ip_mib_lock
 *===========================================================================
 * Description: Protects MIB variables in SNMPv2-MIB from multiple access
 * Parameters: lock - boolean that controls lock or unlock
 * Returns: Nothing
 *
 */
IP_STATIC void
ipnet_ip_mib_lock(Ip_bool lock)
{
    if(lock == IP_TRUE)
    {
        IPNET_CODE_LOCK_WRITE();
    }
    else
    {
        IPNET_CODE_UNLOCK();
    }
}


/*
 *===========================================================================
 *                      ipnet_ip_mib_handler_scalars
 *===========================================================================
 * Description: MIB handler for ipForwarding and IpDefaultTTL
 * Parameters: See file 'ipsnmp.h'
 * Returns: IPSNMP_ERROR_XXX
 *
 */
IP_STATIC Ip_s32
ipnet_ip_mib_handler_scalars(Ip_s32 cmd,
                             char *id,
                             Ipsnmp_varbind *vb,
                             Ip_s32 magic,
                             struct Ipsnmp_node_object *nodeobj)
{
    Ip_s32 ret = -1;
    Ip_s32 lid;
    char *iid;

    (void)id;
    lid = ipsnmp_util_last_subid(nodeobj->id);
    ip_assert(lid == 1 || lid == 2);
    if(cmd == IPSNMP_MIB_COMMAND_GET || cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        iid = ipsnmp_create_iid_integer(nodeobj->id, 0);
        if(iid == IP_NULL)
            return IPSNMP_ERROR_GENERROR;

        if(lid == 1)    /* ipForwarding */
        {
            if(IP_BIT_ISSET(ipnet_flags, IPNET_FLAG_IPV4_FORWARD_PKT))
                ret = ipsnmp_util_put_integer(magic, iid, 1);   /* forwarding */
            else
                ret = ipsnmp_util_put_integer(magic, iid, 2);   /* not forwarding */
        }
        else    /* ipDefaultTTL */
        {
            Ip_s32 ttl;

            ttl = ipcom_sysvar_get_as_int0("ipnet.inet.BaseHopLimit", 64);
            ret = ipsnmp_util_put_integer(magic, iid, ttl);
        }

        ipcom_free(iid);
    }

    if (cmd == IPSNMP_MIB_COMMAND_TEST || cmd == IPSNMP_MIB_COMMAND_SET)
    {
        Ip_s32 tmp;
        char   buf[16];

        ret = ipsnmp_util_get_integer(vb, &tmp);
        if(ret == IPSNMP_ERROR_NOERROR)
        {
            if(lid == 1)    /* ipForwarding */
            {
                if(tmp != 1 && tmp != 2)
                    return IPSNMP_ERROR_WRONGVALUE;
            }
            else    /* ipDefaultTTL */
            {
                if(tmp < 1 || tmp > 255)
                    return IPSNMP_ERROR_WRONGVALUE;
            }
        }

        if (ret == IPSNMP_ERROR_NOERROR && cmd == IPSNMP_MIB_COMMAND_SET)
        {
            if (lid == 1)    /* ipForwarding */
            {
                if (tmp == 1)
                    IP_BIT_SET(ipnet_flags, IPNET_FLAG_IPV4_FORWARD_PKT);  /* forwarding */
                else
                    IP_BIT_CLR(ipnet_flags, IPNET_FLAG_IPV4_FORWARD_PKT);  /* not forwarding */

            }
            else    /* ipDefaultTTL */
            {
                ipcom_sprintf(buf, "%d", (int)tmp);
                if (ipcom_sysvar_set("ipnet.inet.BaseHopLimit",
                                     buf,
                                     IPCOM_SYSVAR_FLAG_OVERWRITE) != IPCOM_SUCCESS)
                {
                    ret = IPSNMP_ERROR_GENERROR;
                }
            }
        }
    }

    return ret;
}


/*
 *===========================================================================
 *                      ipnet_ip_mib_table_search_ipAddrTable
 *===========================================================================
 * Description: Searches ipAddrTable for a matching entry
 * Parameters: id, buf, best, cmd
 * Returns:    The best matching interface to IP_NULL if no matching interface
 *             exists.
 *
 */
IP_STATIC Ipnet_netif *
ipnet_ip_mib_table_search_ipAddrTable(char *id,
                                      char *buf,
                                      char *best,
                                      Ip_s32 cmd,
                                      Ip_s32 *error_code)
{
    Ip_u32       ipAdEntAddr = 0;
    Ip_u32       i;
    Ipnet_netif *netif;
    Ipnet_netif *best_netif = IP_NULL;

    bestaddr = IP_NULL;
    IPNET_NETIF_FOR_EACH(netif, i)
    {
        struct Ipnet_ip4_addr_entry_struct *addr;

        buf[0] = '\0';

        addr = netif->inet4_addr_list;
        while(addr != IP_NULL)
        {
            Ip_s32 lex, len = 0;

            /* Skip multicast addresses */
            if(IP_IN_CLASSD(addr->ipaddr_n))
                goto next;

            /* Skip broadcast addresses */
            if (addr->type != IPNET_ADDR_TYPE_UNICAST)
                goto next;

            ipAdEntAddr = addr->ipaddr_n;

            *error_code = IPSNMP_ERROR_GENERROR;
            if(ipcom_inet_ntop(IP_AF_INET, &ipAdEntAddr, &buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len) == IP_NULL)
                return IP_NULL;
            len = ipcom_strlen(buf);
            if(ipcom_snprintf(&buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, ".") < 0)
                return IP_NULL;
            len = ipcom_strlen(buf);
            if(len)
                buf[len-1] = '\0';

            lex = ipsnmp_util_lexcmp_oid(buf, id);
            if(cmd == IPSNMP_MIB_COMMAND_NEXT)
            {
                if(lex > 0)
                {
                    if(best_netif == IP_NULL || ipsnmp_util_lexcmp_oid(buf, best) < 0)
                    {
                        ipcom_strcpy(best, buf);
                        best_netif = netif;
                        bestaddr = addr;
                    }
                }
            }
            else
            {
                if(lex == 0)
                {
                    ipcom_strcpy(best, buf);
                    best_netif = netif;
                    bestaddr = addr;
                    goto done;
                }
            }
next:
            addr = addr->next;
        }
    }

done:
    if (best_netif == IP_NULL)
        *error_code = IPSNMP_ERROR_NOSUCHNAME;
    return best_netif;
}

/*
 *===========================================================================
 *                      ipnet_ip_mib_cb_ipNetToMediaTable
 *===========================================================================
 * Description:
 * Parameters:
 * Returns:
 *
 */
IP_STATIC Ip_bool
ipnet_ip_mib_cb_ipNetToMediaTable(Ipnet_route_entry *rt, Ipsnmp_route_walk *rwp)
{
    Ip_s32 lex, len = 0;

    /* Early exit if exact match was found previously */
    if(rwp->bestrt != IP_NULL &&
        (rwp->cmd == IPSNMP_MIB_COMMAND_GET
        || rwp->cmd == IPSNMP_MIB_COMMAND_TEST
        || rwp->cmd == IPSNMP_MIB_COMMAND_SET))
        goto exit;

    if(rt->netif == IP_NULL)
        goto exit;
    /* Do not use hidden entries */
    if(IP_BIT_ISSET(rt->hdr.flags, IPNET_RTF_X_HIDDEN))
        goto exit;
    /* Use only link layer entries */
    if(IP_BIT_ISFALSE(rt->hdr.flags, IPNET_RTF_LLINFO))
        goto exit;
    ip_assert(rt->gateway != IP_NULL);
    ip_assert(rt->hdr.key != IP_NULL);

    rwp->buf[0] = '\0';
    if(ipcom_snprintf(&rwp->buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, "%ld.", rt->netif->ipcom.ifindex) < 0)
        goto exit;
    len = ipcom_strlen(rwp->buf);

    if(ipcom_inet_ntop(IP_AF_INET, rt->hdr.key, &rwp->buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len) == IP_NULL)
        goto exit;
    len = ipcom_strlen(rwp->buf);
    if(ipcom_snprintf(&rwp->buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, ".") < 0)
        goto exit;
    len = ipcom_strlen(rwp->buf);
    if(len)
        rwp->buf[len-1] = '\0';

    lex = ipsnmp_util_lexcmp_oid(rwp->buf, rwp->id);
    if(rwp->cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        if(lex > 0)
        {
            if(rwp->bestrt == IP_NULL || ipsnmp_util_lexcmp_oid(rwp->buf, rwp->best) < 0)
            {
                ipcom_strcpy(rwp->best, rwp->buf);
                rwp->bestrt = rt;
            }
        }
    }
    else
    {
        if(lex == 0)
        {
            ipcom_strcpy(rwp->best, rwp->buf);
            rwp->bestrt = rt;
        }
    }

exit:
    /* Do not delete the entry */
    return IP_FALSE;
}


/*
 *===========================================================================
 *                      ipnet_ip_mib_table_search_ipNetToMediaTable
 *===========================================================================
 * Description: Searches ipNetToMediaTable for a matching entry
 * Parameters: id, buf, best, cmd
 * Returns: Row index of the found entry OR -1 if not found OR -2 for error
 *
 */
IP_STATIC Ip_s32
ipnet_ip_mib_table_search_ipNetToMediaTable(char *id,
                                            char *buf,
                                            char *best,
                                            Ip_s32 cmd)
{
    Ipcom_route *rtab;

    if (ipnet_route_get_rtab(IP_AF_INET, 0, IPCOM_ROUTE_TABLE_DEFAULT, &rtab) < 0)
        return -1;

    routewalk.cmd = cmd;
    routewalk.id = id;
    routewalk.buf = buf;
    routewalk.best = best;
    routewalk.bestrt = IP_NULL;

    /* For now handle only the default route table */
    ipcom_route_walk_tree(rtab,
                          (Ip_bool(*)(Ipcom_route_entry *, void *))
                          ipnet_ip_mib_cb_ipNetToMediaTable, &routewalk);

    if(routewalk.bestrt == IP_NULL)
        return -1;
    return 0;
}

/*
 *===========================================================================
 *                      ipnet_ip_mib_handler_ipAddrTable
 *===========================================================================
 * Description: MIB handler for variables in ipAddrTable
 * Parameters: See file 'ipsnmp.h'
 * Returns: IPSNMP_ERROR_XXX
 *
 */
IP_STATIC Ip_s32
ipnet_ip_mib_handler_ipAddrTable(Ip_s32 cmd,
                                 char *id,
                                 Ipsnmp_varbind *vb,
                                 Ip_s32 magic,
                                 struct Ipsnmp_node_object *nodeobj)
{
    Ip_s32       lid, ret = -1;
    char        *iid;
    char        *buf = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    char        *best = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    Ipnet_netif *best_netif;

    (void)vb;
    if(buf == IP_NULL || best == IP_NULL)
    {
        ret = IPSNMP_ERROR_GENERROR;
        goto exit;
    }

    lid = ipsnmp_util_last_subid(nodeobj->id);
    ip_assert(lid >= 1 && lid <= 5);
    best_netif = ipnet_ip_mib_table_search_ipAddrTable(id, buf, best, cmd, &ret);
    if (best_netif == IP_NULL)
        goto exit;

    if(cmd == IPSNMP_MIB_COMMAND_GET || cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        iid = ipsnmp_create_iid_direct(nodeobj->id, best);
        if(iid == IP_NULL)
        {
            ret = IPSNMP_ERROR_GENERROR;
            goto exit;
        }

        ip_assert(bestaddr != IP_NULL);
        switch(lid)
        {
            case 1: /* ipAdEntAddr */
                ret = ipsnmp_util_put_ipaddress(magic, iid, ip_ntohl(bestaddr->ipaddr_n));
                break;
            case 2: /* ipAdEntIfIndex */
                ret = ipsnmp_util_put_integer(magic, iid, best_netif->ipcom.ifindex);
                break;
            case 3: /* ipAdEntNetMask */
                ret = ipsnmp_util_put_ipaddress(magic, iid, ip_ntohl(bestaddr->netmask_n));
                break;
            case 4: /* ipAdEntBcastAddr */
                ret = ipsnmp_util_put_integer(magic, iid, ip_ntohl((bestaddr->ipaddr_n & bestaddr->netmask_n) | ~bestaddr->netmask_n) & 1);
                break;
            case 5: /* ipAdEntReasmMaxSize */
#ifdef IPNET_USE_PACKET_POOL
                ret = ipsnmp_util_put_integer(magic, iid, ipnet->pkt_pool_max_mtu);
#else
                ret = ipsnmp_util_put_integer(magic, iid, -1);
#endif
                break;
            default:
                IP_PANIC();
                ret = IPSNMP_ERROR_GENERROR;
                break;
        }

        ipcom_free(iid);
    }

exit:
    if(buf != IP_NULL)
        ipcom_free(buf);
    if(best != IP_NULL)
        ipcom_free(best);
    return ret;
}


/*
 *===========================================================================
 *                      ipnet_ip_mib_handler_ipNetToMediaTable
 *===========================================================================
 * Description: MIB handler for ipNetToMediaTable
 * Parameters: See file 'ipsnmp.h'
 * Returns: IPSNMP_ERROR_XXX
 *
 */
IP_STATIC Ip_s32
ipnet_ip_mib_handler_ipNetToMediaTable(Ip_s32 cmd,
                                       char *id,
                                       Ipsnmp_varbind *vb,
                                       Ip_s32 magic,
                                       struct Ipsnmp_node_object *nodeobj)
{
    Ip_s32 lid, bestindex, ret = -1;
    char *iid;
    char *buf = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    char *best = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    struct Ip_sockaddr_dl *dl;
    struct Ip_arpreq arpreq;
    struct Ip_sockaddr_in *addr = (struct Ip_sockaddr_in *) &arpreq.arp_pa;
    Ip_s32 ipNetToMediaType;
    Ip_fd  fd;

    if(buf == IP_NULL || best == IP_NULL)
    {
        ret = IPSNMP_ERROR_GENERROR;
        goto exit;
    }

    lid = ipsnmp_util_last_subid(nodeobj->id);
    ip_assert(lid >= 1 && lid <= 4);
    bestindex = ipnet_ip_mib_table_search_ipNetToMediaTable(id, buf, best, cmd);
    if(bestindex == -2)
    {
        ret = IPSNMP_ERROR_GENERROR;
        goto exit;
    }
    else if(bestindex == -1)
    {
        ret = IPSNMP_ERROR_NOSUCHNAME;
        goto exit;
    }

    if(cmd == IPSNMP_MIB_COMMAND_GET || cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        iid = ipsnmp_create_iid_direct(nodeobj->id, best);
        if(iid == IP_NULL)
        {
            ret = IPSNMP_ERROR_GENERROR;
            goto exit;
        }

        ip_assert(routewalk.bestrt != IP_NULL);
        switch(lid)
        {
            case 1: /* ipNetToMediaIfIndex */
                ret = ipsnmp_util_put_integer(magic, iid, routewalk.bestrt->netif->ipcom.ifindex);
                break;
            case 2: /* ipNetToMediaPhysAddress */
                dl = (struct Ip_sockaddr_dl *)routewalk.bestrt->gateway;
                ret = ipsnmp_util_put_octetstring(magic, iid, (Ip_u8 *)IP_SOCKADDR_DL_LLADDR(routewalk.bestrt->gateway), dl->sdl_alen);
                break;
            case 3: /* ipNetToMediaNetAddress */
                ret = ipsnmp_util_put_ipaddress(magic, iid, ip_ntohl(*(Ip_u32 *)routewalk.bestrt->hdr.key));
                break;
            case 4: /* ipNetToMediaType */
                if(IP_BIT_ISSET(routewalk.bestrt->hdr.flags, IPNET_RTF_STATIC))
                    ret = ipsnmp_util_put_integer(magic, iid, 4);   /* static */
                else
                    ret = ipsnmp_util_put_integer(magic, iid, 3);   /* dynamic */
                break;
            default:
                IP_PANIC();
                ret = IPSNMP_ERROR_GENERROR;
                break;
        }

        ipcom_free(iid);
    }

    if(cmd == IPSNMP_MIB_COMMAND_TEST || cmd == IPSNMP_MIB_COMMAND_SET)
    {
        switch(lid)
        {
            case 1: /* ipNetToMediaIfIndex */
            case 2: /* ipNetToMediaPhysAddress */
            case 3: /* ipNetToMediaNetAddress */
                ret = IPSNMP_ERROR_NOSUCHNAME;
                break;
            case 4: /* ipNetToMediaType */
                ret = ipsnmp_util_get_integer(vb, &ipNetToMediaType);
                if(ret == IPSNMP_ERROR_NOERROR)
                {
                    if(ipNetToMediaType < 1 || ipNetToMediaType > 4)
                    {
                        ret = IPSNMP_ERROR_WRONGVALUE;
                    }
                }

                if(ret == IPSNMP_ERROR_NOERROR && cmd == IPSNMP_MIB_COMMAND_SET)
                {
                    if(ipNetToMediaType == 2)
                    {
                        fd = ipnet_do_socket(IP_AF_INET, IP_SOCK_DGRAM, IP_IPPROTO_UDP, IP_FALSE);
                        if(fd != IP_INVALID_SOCKET)
                        {
                            /* Remove the ARP entry */
                            ipcom_memset(&arpreq, 0, sizeof(arpreq));
                            arpreq.arp_ha.sdl_index = (Ip_u16)routewalk.bestrt->netif->ipcom.ifindex;
                            IPCOM_SA_LEN_SET(addr, sizeof(struct Ip_sockaddr));
                            addr->sin_family = IP_AF_INET;
                            addr->sin_addr.s_addr = *(Ip_u32 *)routewalk.bestrt->hdr.key;

                            if(ipnet_sys_socketioctl(fd, IP_SIOCDARP, &arpreq) < 0)
                            {
                                IPCOM_LOG1(ERR, "Failed to remove arp entry: %s", ipcom_strerror(ipcom_errno));
                                ret = IPSNMP_ERROR_GENERROR;
                            }
                            ipnet_sys_socketclose(fd);
                        }
                        else
                        {
                            IPCOM_LOG0(ERR, "Failed to create socket for ioctl call");
                            ret = IPSNMP_ERROR_GENERROR;
                        }
                    }
                }
                break;
            default:
                IP_PANIC();
                ret = IPSNMP_ERROR_GENERROR;
                break;
        }

    }

exit:
    if(buf != IP_NULL)
        ipcom_free(buf);
    if(best != IP_NULL)
        ipcom_free(best);
    return ret;
}


/*
 ****************************************************************************
 * 10                    GLOBAL FUNCTIONS
 ****************************************************************************
 */

/*
 ****************************************************************************
 * 11                    PUBLIC FUNCTIONS
 ****************************************************************************
 */

/*
 *===========================================================================
 *                      ipnet_ip_mib_init
 *===========================================================================
 * Description: Initializes IP-MIB
 * Parameters: None
 * Returns: IPCOM_SUCCESS or IPCOM_ERR_FAILED
 *
 */
IP_PUBLIC Ip_err
ipnet_ip_mib_init(void)
{
    struct Ipsnmp_node_object nodeobj;
    Ip_s32 ret;

    /* Assign lock function */
    nodeobj.lock = ipnet_ip_mib_lock;

    /* Add node "ipMIB" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.48";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipMIB";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ip" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.4";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ip";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmp" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.5";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "icmp";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipForwarding" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READWRITE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ip_mib_handler_scalars;
    nodeobj.id = "1.3.6.1.2.1.4.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipForwarding";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipDefaultTTL" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READWRITE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ip_mib_handler_scalars;
    nodeobj.id = "1.3.6.1.2.1.4.2";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipDefaultTTL";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipInReceives" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.4.3";
    nodeobj.instance = &ipnet->mib2.ipInReceives;
#ifdef IP_DEBUG
    nodeobj.name = "ipInReceives";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipInHdrErrors" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.4.4";
    nodeobj.instance = &ipnet->mib2.ipInHdrErrors;
#ifdef IP_DEBUG
    nodeobj.name = "ipInHdrErrors";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipInAddrErrors" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.4.5";
    nodeobj.instance = &ipnet->mib2.ipInAddrErrors;
#ifdef IP_DEBUG
    nodeobj.name = "ipInAddrErrors";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipForwDatagrams" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.4.6";
    nodeobj.instance = &ipnet->mib2.ipForwDatagrams;
#ifdef IP_DEBUG
    nodeobj.name = "ipForwDatagrams";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipInUnknownProtos" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.4.7";
    nodeobj.instance = &ipnet->mib2.ipInUnknownProtos;
#ifdef IP_DEBUG
    nodeobj.name = "ipInUnknownProtos";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipInDiscards" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.4.8";
    nodeobj.instance = &ipnet->mib2.ipInDiscards;
#ifdef IP_DEBUG
    nodeobj.name = "ipInDiscards";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipInDelivers" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.4.9";
    nodeobj.instance = &ipnet->mib2.ipInDelivers;
#ifdef IP_DEBUG
    nodeobj.name = "ipInDelivers";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipOutRequests" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.4.10";
    nodeobj.instance = &ipnet->mib2.ipOutRequests;
#ifdef IP_DEBUG
    nodeobj.name = "ipOutRequests";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipOutDiscards" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.4.11";
    nodeobj.instance = &ipnet->mib2.ipOutDiscards;
#ifdef IP_DEBUG
    nodeobj.name = "ipOutDiscards";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipOutNoRoutes" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.4.12";
    nodeobj.instance = &ipnet->mib2.ipOutNoRoutes;
#ifdef IP_DEBUG
    nodeobj.name = "ipOutNoRoutes";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipReasmTimeout" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.4.13";
    nodeobj.instance = &ipnet->mib2.ipReasmTimeout;
#ifdef IP_DEBUG
    nodeobj.name = "ipReasmTimeout";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipReasmReqds" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.4.14";
    nodeobj.instance = &ipnet->mib2.ipReasmReqds;
#ifdef IP_DEBUG
    nodeobj.name = "ipReasmReqds";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipReasmOKs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.4.15";
    nodeobj.instance = &ipnet->mib2.ipReasmOKs;
#ifdef IP_DEBUG
    nodeobj.name = "ipReasmOKs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipReasmFails" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.4.16";
    nodeobj.instance = &ipnet->mib2.ipReasmFails;
#ifdef IP_DEBUG
    nodeobj.name = "ipReasmFails";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipFragOKs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.4.17";
    nodeobj.instance = &ipnet->mib2.ipFragOKs;
#ifdef IP_DEBUG
    nodeobj.name = "ipFragOKs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipFragFails" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.4.18";
    nodeobj.instance = &ipnet->mib2.ipFragFails;
#ifdef IP_DEBUG
    nodeobj.name = "ipFragFails";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipFragCreates" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.4.19";
    nodeobj.instance = &ipnet->mib2.ipFragCreates;
#ifdef IP_DEBUG
    nodeobj.name = "ipFragCreates";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipAddrTable" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.4.20";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipAddrTable";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipAddrEntry" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.4.20.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipAddrEntry";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipAdEntAddr" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_IPADDRESS;
    nodeobj.handler = ipnet_ip_mib_handler_ipAddrTable;
    nodeobj.id = "1.3.6.1.2.1.4.20.1.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipAdEntAddr";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipAdEntIfIndex" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ip_mib_handler_ipAddrTable;
    nodeobj.id = "1.3.6.1.2.1.4.20.1.2";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipAdEntIfIndex";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipAdEntNetMask" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_IPADDRESS;
    nodeobj.handler = ipnet_ip_mib_handler_ipAddrTable;
    nodeobj.id = "1.3.6.1.2.1.4.20.1.3";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipAdEntNetMask";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipAdEntBcastAddr" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ip_mib_handler_ipAddrTable;
    nodeobj.id = "1.3.6.1.2.1.4.20.1.4";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipAdEntBcastAddr";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipAdEntReasmMaxSize" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ip_mib_handler_ipAddrTable;
    nodeobj.id = "1.3.6.1.2.1.4.20.1.5";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipAdEntReasmMaxSize";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipNetToMediaTable" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.4.22";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipNetToMediaTable";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipNetToMediaEntry" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.4.22.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipNetToMediaEntry";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipNetToMediaIfIndex" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READCREATE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ip_mib_handler_ipNetToMediaTable;
    nodeobj.id = "1.3.6.1.2.1.4.22.1.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipNetToMediaIfIndex";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipNetToMediaPhysAddress" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READCREATE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_OCTETSTRING;
    nodeobj.handler = ipnet_ip_mib_handler_ipNetToMediaTable;
    nodeobj.id = "1.3.6.1.2.1.4.22.1.2";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipNetToMediaPhysAddress";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipNetToMediaNetAddress" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READCREATE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_IPADDRESS;
    nodeobj.handler = ipnet_ip_mib_handler_ipNetToMediaTable;
    nodeobj.id = "1.3.6.1.2.1.4.22.1.3";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipNetToMediaNetAddress";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipNetToMediaType" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READCREATE;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_ip_mib_handler_ipNetToMediaTable;
    nodeobj.id = "1.3.6.1.2.1.4.22.1.4";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "ipNetToMediaType";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "ipRoutingDiscards" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.4.23";
    nodeobj.instance = &ipnet->mib2.ipRoutingDiscards;
#ifdef IP_DEBUG
    nodeobj.name = "ipRoutingDiscards";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpInMsgs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.1";
    nodeobj.instance = &ipnet->mib2.icmpInMsgs;
#ifdef IP_DEBUG
    nodeobj.name = "icmpInMsgs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpInErrors" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.2";
    nodeobj.instance = &ipnet->mib2.icmpInErrors;
#ifdef IP_DEBUG
    nodeobj.name = "icmpInErrors";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpInDestUnreachs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.3";
    nodeobj.instance = &ipnet->mib2.icmpInDestUnreachs;
#ifdef IP_DEBUG
    nodeobj.name = "icmpInDestUnreachs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpInTimeExcds" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.4";
    nodeobj.instance = &ipnet->mib2.icmpInTimeExcds;
#ifdef IP_DEBUG
    nodeobj.name = "icmpInTimeExcds";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpInParmProbs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.5";
    nodeobj.instance = &ipnet->mib2.icmpInParmProbs;
#ifdef IP_DEBUG
    nodeobj.name = "icmpInParmProbs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpInSrcQuenchs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.6";
    nodeobj.instance = &ipnet->mib2.icmpInSrcQuenchs;
#ifdef IP_DEBUG
    nodeobj.name = "icmpInSrcQuenchs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpInRedirects" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.7";
    nodeobj.instance = &ipnet->mib2.icmpInRedirects;
#ifdef IP_DEBUG
    nodeobj.name = "icmpInRedirects";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpInEchos" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.8";
    nodeobj.instance = &ipnet->mib2.icmpInEchos;
#ifdef IP_DEBUG
    nodeobj.name = "icmpInEchos";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpInEchoReps" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.9";
    nodeobj.instance = &ipnet->mib2.icmpInEchoReps;
#ifdef IP_DEBUG
    nodeobj.name = "icmpInEchoReps";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpInTimestamps" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.10";
    nodeobj.instance = &ipnet->mib2.icmpInTimestamps;
#ifdef IP_DEBUG
    nodeobj.name = "icmpInTimestamps";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpInTimestampReps" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.11";
    nodeobj.instance = &ipnet->mib2.icmpInTimestampReps;
#ifdef IP_DEBUG
    nodeobj.name = "icmpInTimestampReps";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpInAddrMasks" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.12";
    nodeobj.instance = &ipnet->mib2.icmpInAddrMasks;
#ifdef IP_DEBUG
    nodeobj.name = "icmpInAddrMasks";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpInAddrMaskReps" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.13";
    nodeobj.instance = &ipnet->mib2.icmpInAddrMaskReps;
#ifdef IP_DEBUG
    nodeobj.name = "icmpInAddrMaskReps";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpOutMsgs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.14";
    nodeobj.instance = &ipnet->mib2.icmpOutMsgs;
#ifdef IP_DEBUG
    nodeobj.name = "icmpOutMsgs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpOutErrors" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.15";
    nodeobj.instance = &ipnet->mib2.icmpOutErrors;
#ifdef IP_DEBUG
    nodeobj.name = "icmpOutErrors";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpOutDestUnreachs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.16";
    nodeobj.instance = &ipnet->mib2.icmpOutDestUnreachs;
#ifdef IP_DEBUG
    nodeobj.name = "icmpOutDestUnreachs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpOutTimeExcds" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.17";
    nodeobj.instance = &ipnet->mib2.icmpOutTimeExcds;
#ifdef IP_DEBUG
    nodeobj.name = "icmpOutTimeExcds";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpOutParmProbs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.18";
    nodeobj.instance = &ipnet->mib2.icmpOutParmProbs;
#ifdef IP_DEBUG
    nodeobj.name = "icmpOutParmProbs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpOutSrcQuenchs" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.19";
    nodeobj.instance = &ipnet->mib2.icmpOutSrcQuenchs;
#ifdef IP_DEBUG
    nodeobj.name = "icmpOutSrcQuenchs";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpOutRedirects" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.20";
    nodeobj.instance = &ipnet->mib2.icmpOutRedirects;
#ifdef IP_DEBUG
    nodeobj.name = "icmpOutRedirects";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpOutEchos" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.21";
    nodeobj.instance = &ipnet->mib2.icmpOutEchos;
#ifdef IP_DEBUG
    nodeobj.name = "icmpOutEchos";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpOutEchoReps" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.22";
    nodeobj.instance = &ipnet->mib2.icmpOutEchoReps;
#ifdef IP_DEBUG
    nodeobj.name = "icmpOutEchoReps";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpOutTimestamps" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.23";
    nodeobj.instance = &ipnet->mib2.icmpOutTimestamps;
#ifdef IP_DEBUG
    nodeobj.name = "icmpOutTimestamps";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpOutTimestampReps" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.24";
    nodeobj.instance = &ipnet->mib2.icmpOutTimestampReps;
#ifdef IP_DEBUG
    nodeobj.name = "icmpOutTimestampReps";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpOutAddrMasks" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.25";
    nodeobj.instance = &ipnet->mib2.icmpOutAddrMasks;
#ifdef IP_DEBUG
    nodeobj.name = "icmpOutAddrMasks";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "icmpOutAddrMaskReps" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.5.26";
    nodeobj.instance = &ipnet->mib2.icmpOutAddrMaskReps;
#ifdef IP_DEBUG
    nodeobj.name = "icmpOutAddrMaskReps";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    return IPCOM_SUCCESS;
}

#endif /* #if defined(IPCOM_USE_MIB2) && defined(IPCOM_USE_INET) */
#endif /* #ifdef IPSNMP */

#if !defined(IPSNMP) || !defined(IPCOM_USE_MIB2)
void ipnet_ip_mib_empty_file(void);
void ipnet_ip_mib_empty_file(void) { }
#endif


/*
 ****************************************************************************
 *                     END OF FILE
 ****************************************************************************
 */

