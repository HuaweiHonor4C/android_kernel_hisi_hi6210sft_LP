/*
 ******************************************************************************
 *                     INTERPEAK SOURCE FILE
 *
 *   Document no: @(#) $Name: VXWORKS_ITER18A_FRZ10 $ $RCSfile: ipnet_udp_mib.c,v $ $Revision: 1.21 $
 *   $Source: /home/interpeak/CVSRoot/ipnet2/src/ipnet_udp_mib.c,v $
 *   $Author: kenneth $
 *   $State: Exp $ $Locker:  $
 *
 *   INTERPEAK_COPYRIGHT_STRING
 *   Design and implementation by Markus Carlstedt <markus@interpeak.se>
 ******************************************************************************
 */

/*
 ****************************************************************************
 * 1                    DESCRIPTION
 ****************************************************************************
 */

/*
 *===========================================================================
 *                      UDP-MIB
 *===========================================================================
 *
 * Autogenerated by 'ipmibc' with 'smidump 0.4.1' on 2003-11-20 at 11:29:32
 *
 * This file includes initialization code and stubs for MIB variables defined
 * in UDP-MIB. Without any changes it should compile and run with the
 * behaviour that GetRequests succeed with the returned value being
 * zero. SetRequests also succeed but without any actual variables
 * being updated.
 *
 * Modifications to this file are necessary in order to enable read and
 * write operations on actual variables presented in the MIB interface.
 * Each segment in the code where a change is proposed is marked with a
 * 'MIB_TODO' comment together with a pseudo code example describing the
 * modification.
 *
 * This file shall normally be compiled together with the product to which
 * SNMP support is to be added and then linked with the IPSNMP libraries.
 * The MIB is initialized by calling the public initialization function defined
 * at the end of this file. Since no header files are generated its function
 * prototype should be copied into the the product that initializes the MIB.
 *
 */

/*
 ****************************************************************************
 * 2                    CONFIGURATION
 ****************************************************************************
 */

#ifndef IPCOM_KERNEL
#define IPCOM_KERNEL
#endif
#include "ipnet_config.h"


/*
 ****************************************************************************
 * 3                    INCLUDE FILES
 ****************************************************************************
 */

#define IPCOM_USE_CLIB_PROTO
#include <ipcom_type.h>
#include <ipcom_cstyle.h>
#include <ipcom_clib.h>
#include <ipcom_syslog.h>
#include <ipcom_err.h>

#ifdef IPSNMP
#include <ipsnmp_config.h>
#include <ipsnmp.h>
#include <ipcom_mib2.h>
#include <ipnet_h.h>

#ifdef IPCOM_USE_MIB2


/*
 ****************************************************************************
 * 4                    DEFINES
 ****************************************************************************
 */

#ifdef IPCOM_SYSLOG_FACILITY
#undef IPCOM_SYSLOG_FACILITY
#endif
#define IPCOM_SYSLOG_FACILITY    IPCOM_LOG_IPSNMP

#ifdef IPCOM_SYSLOG_PRIORITY
#undef IPCOM_SYSLOG_PRIORITY
#endif
#define IPCOM_SYSLOG_PRIORITY    IPCOM_LOG_DEBUG


/*
 ****************************************************************************
 * 5                    TYPES
 ****************************************************************************
 */

/*
 ****************************************************************************
 * 6                    EXTERNAL PROTOTYPES
 ****************************************************************************
 */

/*
 ****************************************************************************
 * 7                    LOCAL PROTOTYPES
 ****************************************************************************
 */

IP_PUBLIC Ip_err ipnet_udp_mib_init(void);



/*
 ****************************************************************************
 * 8                    DATA
 ****************************************************************************
 */

/*
 ****************************************************************************
 * 9                    STATIC FUNCTIONS
 ****************************************************************************
 */

/*
 *===========================================================================
 *                      ipnet_udp_mib_lock
 *===========================================================================
 * Description: Protects MIB variables in SNMPv2-MIB from multiple access
 * Parameters: lock - boolean that controls lock or unlock
 * Returns: Nothing
 *
 */
IP_STATIC void
ipnet_udp_mib_lock(Ip_bool lock)
{
    if(lock == IP_TRUE)
    {
        IPNET_CODE_LOCK_WRITE();
    }
    else
    {
        IPNET_CODE_UNLOCK();
    }
}


#ifdef IPCOM_USE_INET
/*
 *===========================================================================
 *                      ipnet_udp_mib_table_search_udpTable
 *===========================================================================
 * Description: Searches udpTable for a matching entry
 * Parameters: id, buf, best, cmd
 * Returns: Row index of the found entry OR -1 if not found OR -2 for error
 *
 */
IP_STATIC Ip_s32
ipnet_udp_mib_table_search_udpTable(char *id,
                                    char *buf,
                                    char *best,
                                    Ip_s32 cmd)
{
    Ip_u32 udpLocalAddress = 0;
    Ip_s32 udpLocalPort;
    Ip_s32 udpTable_num_entries;
    Ip_s32 i, bestindex = -1;

    udpTable_num_entries = ipnet_conf_max_sockets;

    for(i=0; i<udpTable_num_entries; i++)
    {
        Ip_s32 lex, len = 0;

        buf[0] = '\0';

        if (ipnet->sockets[i] == IP_NULL || ipnet->sockets[i]->ipcom.domain != IP_AF_INET
            || ipnet->sockets[i]->ipcom.type != IP_SOCK_DGRAM || ipnet->sockets[i]->proto != IP_IPPROTO_UDP
            || !IP_BIT_ISSET(ipnet->sockets[i]->flags, IPNET_SOCKET_FLAG_BOUND))
        {
            continue;
        }

        udpLocalAddress = ipnet->sockets[i]->ip4->saddr_n;

        if(ipcom_inet_ntop(IP_AF_INET, &udpLocalAddress, &buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len) == IP_NULL)
            return -2;
        len = ipcom_strlen(buf);
        if(ipcom_snprintf(&buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, ".") < 0)
            return -2;
        len = ipcom_strlen(buf);

        udpLocalPort = ipnet->sockets[i]->sport;

        if(ipcom_snprintf(&buf[len], IPSNMP_CONFIG_MAX_OBJECT_ID-len, "%d.", (int)udpLocalPort) < 0)
            return -2;
        len = ipcom_strlen(buf);
        if(len)
            buf[len-1] = '\0';

        lex = ipsnmp_util_lexcmp_oid(buf, id);
        if(cmd == IPSNMP_MIB_COMMAND_NEXT)
        {
            if(lex > 0)
            {
                if(bestindex == -1 || ipsnmp_util_lexcmp_oid(buf, best) < 0)
                {
                    ipcom_strcpy(best, buf);
                    bestindex = i;
                }
            }
        }
        else
        {
            if(lex == 0)
            {
                ipcom_strcpy(best, buf);
                bestindex = i;
                break;
            }
        }
    }

    return bestindex;
}


/*
 *===========================================================================
 *                      ipnet_udp_mib_handler_udpLocalAddress
 *===========================================================================
 * Description: MIB handler for udpLocalAddress
 * Parameters: See file 'ipsnmp.h'
 * Returns: IPSNMP_ERROR_XXX
 *
 */
IP_STATIC Ip_s32
ipnet_udp_mib_handler_udpLocalAddress(Ip_s32 cmd,
                                      char *id,
                                      Ipsnmp_varbind *vb,
                                      Ip_s32 magic,
                                      struct Ipsnmp_node_object *nodeobj)
{
    Ip_s32 bestindex, ret = -1;
    Ip_u32 udpLocalAddress;
    char *iid;
    char *buf = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    char *best = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);

    (void)vb;
    if(buf == IP_NULL || best == IP_NULL)
    {
        ret = IPSNMP_ERROR_GENERROR;
        goto exit;
    }

    bestindex = ipnet_udp_mib_table_search_udpTable(id, buf, best, cmd);
    if(bestindex == -2)
    {
        ret = IPSNMP_ERROR_GENERROR;
        goto exit;
    }
    else if(bestindex == -1)
    {
        ret = IPSNMP_ERROR_NOSUCHNAME;
        goto exit;
    }

    if(cmd == IPSNMP_MIB_COMMAND_GET || cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        iid = ipsnmp_create_iid_direct(nodeobj->id, best);
        if(iid == IP_NULL)
        {
            ret = IPSNMP_ERROR_GENERROR;
            goto exit;
        }

        udpLocalAddress = ip_ntohl(ipnet->sockets[bestindex]->ip4->saddr_n);

        ret = ipsnmp_util_put_ipaddress(magic, iid, udpLocalAddress);
        ipcom_free(iid);
    }

exit:
    if(buf != IP_NULL)
        ipcom_free(buf);
    if(best != IP_NULL)
        ipcom_free(best);
    return ret;
}


/*
 *===========================================================================
 *                      ipnet_udp_mib_handler_udpLocalPort
 *===========================================================================
 * Description: MIB handler for udpLocalPort
 * Parameters: See file 'ipsnmp.h'
 * Returns: IPSNMP_ERROR_XXX
 *
 */
IP_STATIC Ip_s32
ipnet_udp_mib_handler_udpLocalPort(Ip_s32 cmd,
                                   char *id,
                                   Ipsnmp_varbind *vb,
                                   Ip_s32 magic,
                                   struct Ipsnmp_node_object *nodeobj)
{
    Ip_s32 bestindex, ret = -1;
    Ip_s32 udpLocalPort;
    char *iid;
    char *buf = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);
    char *best = ipcom_malloc(IPSNMP_CONFIG_MAX_OBJECT_ID);

    (void)vb;
    if(buf == IP_NULL || best == IP_NULL)
    {
        ret = IPSNMP_ERROR_GENERROR;
        goto exit;
    }

    bestindex = ipnet_udp_mib_table_search_udpTable(id, buf, best, cmd);
    if(bestindex == -2)
    {
        ret = IPSNMP_ERROR_GENERROR;
        goto exit;
    }
    else if(bestindex == -1)
    {
        ret = IPSNMP_ERROR_NOSUCHNAME;
        goto exit;
    }

    if(cmd == IPSNMP_MIB_COMMAND_GET || cmd == IPSNMP_MIB_COMMAND_NEXT)
    {
        iid = ipsnmp_create_iid_direct(nodeobj->id, best);
        if(iid == IP_NULL)
        {
            ret = IPSNMP_ERROR_GENERROR;
            goto exit;
        }

        udpLocalPort = ipnet->sockets[bestindex]->sport;

        ret = ipsnmp_util_put_integer(magic, iid, udpLocalPort);
        ipcom_free(iid);
    }

exit:
    if(buf != IP_NULL)
        ipcom_free(buf);
    if(best != IP_NULL)
        ipcom_free(best);
    return ret;
}
#endif /* #ifdef IPCOM_USE_INET */


/*
 ****************************************************************************
 * 10                    GLOBAL FUNCTIONS
 ****************************************************************************
 */

/*
 ****************************************************************************
 * 11                    PUBLIC FUNCTIONS
 ****************************************************************************
 */

/*
 *===========================================================================
 *                      ipnet_udp_mib_init
 *===========================================================================
 * Description: Initializes UDP-MIB
 * Parameters: None
 * Returns: IPCOM_SUCCESS or IPCOM_ERR_FAILED
 *
 */
IP_PUBLIC Ip_err
ipnet_udp_mib_init(void)
{
    struct Ipsnmp_node_object nodeobj;
    Ip_s32 ret;

    /* Assign lock function */
    nodeobj.lock = ipnet_udp_mib_lock;

    /* Add node "udpMIB" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.50";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "udpMIB";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "udp" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.7";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "udp";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_OTHER;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "udpInDatagrams" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.7.1";
    nodeobj.instance = &ipnet->mib2.udpInDatagrams;
#ifdef IP_DEBUG
    nodeobj.name = "udpInDatagrams";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "udpNoPorts" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.7.2";
    nodeobj.instance = &ipnet->mib2.udpNoPorts;
#ifdef IP_DEBUG
    nodeobj.name = "udpNoPorts";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "udpInErrors" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.7.3";
    nodeobj.instance = &ipnet->mib2.udpInErrors;
#ifdef IP_DEBUG
    nodeobj.name = "udpInErrors";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "udpOutDatagrams" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_COUNTER32;
    nodeobj.handler = ipsnmp_mib_standard_handler;
    nodeobj.id = "1.3.6.1.2.1.7.4";
    nodeobj.instance = &ipnet->mib2.udpOutDatagrams;
#ifdef IP_DEBUG
    nodeobj.name = "udpOutDatagrams";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_SCALAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

#ifdef IPCOM_USE_INET
    /* Add node "udpTable" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.7.5";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "udpTable";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "udpEntry" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_NOACCESS;
    nodeobj.datatype = IPSNMP_DATA_TYPE_UNSPECIFIED;
    nodeobj.handler = IP_NULL;
    nodeobj.id = "1.3.6.1.2.1.7.5.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "udpEntry";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_AGGREGATE;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "udpLocalAddress" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_IPADDRESS;
    nodeobj.handler = ipnet_udp_mib_handler_udpLocalAddress;
    nodeobj.id = "1.3.6.1.2.1.7.5.1.1";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "udpLocalAddress";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }

    /* Add node "udpLocalPort" to the MIB tree */
    nodeobj.access = IPSNMP_NODE_ACCESS_READONLY;
    nodeobj.datatype = IPSNMP_DATA_TYPE_INTEGER;
    nodeobj.handler = ipnet_udp_mib_handler_udpLocalPort;
    nodeobj.id = "1.3.6.1.2.1.7.5.1.2";
    nodeobj.instance = IP_NULL;
#ifdef IP_DEBUG
    nodeobj.name = "udpLocalPort";
#endif
    nodeobj.nodetype = IPSNMP_NODE_TYPE_COLUMNAR;
    ret = ipsnmp_add_node(&nodeobj);
    if(ret != 0)
    {
        IPCOM_LOG2(ERR, "ipsnmp_add_node() :: failed to add %s (%d)", nodeobj.id, ret);
        return IPCOM_ERR_FAILED;
    }
#endif /* #ifdef IPCOM_USE_INET */

    return IPCOM_SUCCESS;
}


#endif /* #ifdef IPCOM_USE_MIB2 */
#endif /* #ifdef IPSNMP */

#if !defined(IPSNMP) || !defined(IPCOM_USE_MIB2)
void ipnet_udp_mib_empty_file(void);
void ipnet_udp_mib_empty_file(void) { }
#endif


/*
 ****************************************************************************
 *                     END OF FILE
 ****************************************************************************
 */
